<!DOCTYPE html>
<html>
<head>
  <title>高楼扔鸡蛋问题</title>
  <link rel="stylesheet" href="/note/note.css">
</head>
<body>
<h1 id="-">高楼扔鸡蛋问题</h1>
<h1 id="-">题目</h1>
<p>若干层楼，若干个鸡蛋，算出最少的尝试次数，找到鸡蛋恰好摔不破的那层楼。</p>
<h2 id="-">问题描述</h2>
<p>面前有一栋从 1 到 N 共 N 层的楼，然后给你 K 个鸡蛋（K 至少为 1）。现在确定这栋楼存在楼层 0 &lt;= F &lt;= N，在这层楼将鸡蛋扔下去，鸡蛋恰好没摔碎（高于 F 的楼层都会碎，低于 F 的楼层都不会碎）。现在问你，最坏情况下，你至少要扔几次鸡蛋，才能确定这个楼层 F 呢？</p>
<h2 id="-">分析</h2>
<p>最坏的情况是结果发生在搜索区间穷尽时，如果不限制鸡蛋个数的话，二分思路显然可以得到最少尝试的次数。</p>
<p>对于动态规划问题：这个问题有什么状态，有什么选择，然后穷举？</p>
<p>状态很明显，就是当前拥有的鸡蛋数K和需要测试的楼层数N。随着测试的进行，鸡蛋个数可能减少，楼层的搜索范围会减小，这就是状态的变化。</p>
<p>选择其实就是去选择哪层楼扔鸡蛋。二分查找每次选择到楼层区间的中间去扔鸡蛋，线性扫描选择一层层向上测试。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">dp</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span><span class="nx">N</span><span class="p">){</span>
    <span class="kd">let</span> <span class="nx">res</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kd">let</span> <span class="nx">i</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span><span class="nx">i</span><span class="o">&lt;=</span><span class="nx">N</span><span class="p">;</span><span class="o">++</span><span class="nx">i</span><span class="p">){</span>
        <span class="nx">res</span><span class="o">=</span><span class="nb">Math</span><span class="p">.</span><span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span><span class="nx">iDropEgg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>第i层扔鸡蛋，可能出现两种情况，鸡蛋碎了，鸡蛋没碎。这时候状态转移就来了。</p>
<p>如果鸡蛋碎了，鸡蛋的个数K减1，搜索的区间从[1,N]变为[1,i-1]。</p>
<p>如果鸡蛋没碎，鸡蛋的个数K不变，搜索的区间从[1,N]变为[i+1,N]。</p>
<p>最坏情况下的扔鸡蛋次数，鸡蛋在第i层楼碎没碎，取决于哪种情况的结果更大。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">// K鸡蛋个数，N楼层数</span>
<span class="kd">let</span> <span class="nx">cache</span> <span class="o">=</span> <span class="p">{};</span>
<span class="kd">function</span> <span class="nx">eggDrop</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">N</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">K</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">N</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">N</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="err">`</span><span class="nx">Egg$</span><span class="p">{</span><span class="nx">K</span><span class="p">}</span><span class="nx">Floor$</span><span class="p">{</span><span class="nx">N</span><span class="p">}</span><span class="err">`</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">key</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="nx">N</span><span class="p">;</span> <span class="o">++</span><span class="nx">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">res</span> <span class="o">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">max</span><span class="p">(</span>
            <span class="nx">eggDrop</span><span class="p">(</span><span class="nx">K</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
            <span class="nx">eggDrop</span><span class="p">(</span><span class="nx">K</span><span class="p">,</span> <span class="nx">N</span> <span class="o">-</span> <span class="nx">i</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">}</span>
    <span class="nx">cache</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>动态规划算法的时间复杂度就是子问题个数x函数本身的复杂度。时间复杂度是O(K*N^2)，空间复杂度O(KN)。</p>
<h2 id="-">疑难解答</h2>
<p>有读者不理解代码为什么用一个for循环遍历楼层[1...N]，这不是线性扫描，只是在做一次选择。</p>
<p>这个问题还有更好的解法，修改代码中的for循环为二分搜索，可以将时间复杂度将为O(K<em>N</em>logN)。</p>
<p>能用二分搜索是因为状态转移方程函数图像具有单调性，可以快速找到最值。</p>
<p>dp(K,N)数组的定义，K固定时，这个函数一定是单调递增的。</p>
<p>dp(K-1,i-1)和dp(K,N-i)这两个函数，其中i是从1到N单增的，如果固定K和N，这个两个函数看作关于i的函数，前者随着i的增加应该是单调递增的，后者随着i的增加应该是单调递减的。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> * </span>
<span class="cm"> * @param {*} k  k个鸡蛋</span>
<span class="cm"> * @param {*} n  n层楼</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nx">dropEggs</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">k</span> <span class="o">===</span> <span class="mi">1</span><span class="p">)</span> <span class="k">return</span> <span class="nx">n</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">n</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">key</span> <span class="o">=</span> <span class="err">`</span><span class="nx">Egg$</span><span class="p">{</span><span class="nx">k</span><span class="p">}</span><span class="nx">Floor$</span><span class="p">{</span><span class="nx">n</span><span class="p">}</span><span class="err">`</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">mem</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">!==</span> <span class="kc">undefined</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nx">mem</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="kd">let</span> <span class="nx">res</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kd">let</span> <span class="nx">left</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">right</span> <span class="o">=</span> <span class="nx">N</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="nx">left</span> <span class="o">&lt;=</span> <span class="nx">right</span><span class="p">)</span> <span class="p">{</span>
        <span class="kd">let</span> <span class="nx">mid</span> <span class="o">=</span> <span class="nb">Number</span><span class="p">.</span><span class="nb">parseInt</span><span class="p">(</span><span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">broken</span> <span class="o">=</span> <span class="nx">dropEggs</span><span class="p">(</span><span class="nx">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
        <span class="kd">let</span> <span class="nx">notBroken</span> <span class="o">=</span> <span class="nx">dropEggs</span><span class="p">(</span><span class="nx">k</span><span class="p">,</span> <span class="nx">N</span> <span class="o">-</span> <span class="nx">mid</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">broken</span> <span class="o">&gt;</span> <span class="nx">notBroken</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">right</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">res</span> <span class="o">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">broken</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nx">left</span> <span class="o">=</span> <span class="nx">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nx">res</span> <span class="o">=</span> <span class="nx">min</span><span class="p">(</span><span class="nx">res</span><span class="p">,</span> <span class="nx">notBroken</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nx">mem</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="o">=</span> <span class="nx">res</span><span class="p">;</span>
    <span class="k">return</span> <span class="nx">res</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
</body>
</html>
