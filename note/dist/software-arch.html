<!DOCTYPE html>
<html>
<head>
  <title>软件架构模式</title>
  <link rel="stylesheet" href="/note/note.css?ts=1645456638699">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="-">软件架构模式</h1>
<p>本文观点和内容参考了《Software Architecture Patterns》的书。</p>
<h2 id="-">为什么要学习基本的软件架构</h2>
<p>1、了解了基本的软件架构知识，你可以更容易理解你所工作的软件项目。</p>
<p>2、知道基础的架构模式可以让你在写代码时做更好的决策。eg：如果你的应用基于事件驱动的微服务，那么做为软件工程师你必须将越来越复杂的代码拆分为独立的服务。</p>
<h2 id="-">五种模式</h2>
<p>1、分层结构。</p>
<p>2、事件驱动结构。</p>
<p>3、微内核架构或插件结构。</p>
<p>4、微服务体系结构。</p>
<p>5、云架构模式。</p>
<h2 id="-">分层结构</h2>
<p>对于单体应用来说，是最常见的软件结构。该模式背后的基本思想是将应用程序逻辑分为几个层，每个层封装特定类型的功能。</p>
<p>eg：持久化层负责app和db的通讯。</p>
<p><img src="/note/assets/imgs/layer-software-arch.png" alt="分层结构图"></p>
<h2 id="-">事件驱动结构</h2>
<p>该模式背后的基本思想是将应用程序分为单一职责的事件处理组件。该组件可以接收并处理事件。</p>
<p>该模式是一种流行的分布式异步体系结构模式，以高可扩展性和适应性而闻名。</p>
<p><img src="/note/assets/imgs/event-software-arch.png" alt="事件驱动结构图"></p>
<h2 id="-">微内核结构或插件结构</h2>
<p>微内核结构，也被称为插件结构。在设计时分为两个组件：核心系统和插件模式。一个比较好的例子是浏览器，你可以安装很多浏览器插件。</p>
<p><img src="/note/assets/imgs/plugin-software-arch.png" alt="插件结构图"></p>
<h2 id="-">微服务结构</h2>
<p>微服务体系结构由单独部署的服务组成，其中每个服务都有单一的职责。这些服务是彼此独立的，如果一个服务失败，其它服务不会停止运行。</p>
<p><img src="/note/assets/imgs/microservices-software-arch.png" alt="微服务结构图"></p>
<h2 id="-">基于空间的结构</h2>
<p>基于空间的模式背后的主要思想是分布式共享内存，以缓解数据库级别经常出现的问题。我们的假设是，通过使用内存中的数据处理大多数操作，我们可以避免数据库中的额外操作，从而避免将来可能出现的任何问题。</p>
<p>基本方式是将应用程序划分为多个处理单元(可根据需要自动放大和缩小)，在这些单元之间复制和处理数据，而无需将数据持久化到中央数据库。</p>
<p><img src="/note/assets/imgs/space-software-arch.png" alt="基于空间的结构图"></p>
<h1 id="-">软件架构模式</h1>
<p>开发人员在没有正式的体系结构的情况下开始编写应用程序是很常见的。</p>
<p>如果没有清晰且定义良好的体系结构，大多数开发人员和架构师将求助于事实上的标准传统分层体系结构模式。</p>
<p>通过将源代码模块分离到包中来创建隐式层，不幸的是，这种做法会产生一系列无组织的源代码模块，它们之间缺乏明确的角色、责任和关系。这被称为大泥球反模式架构。</p>
<p>缺乏正式体系结构的应用程序通常是紧密耦合的、脆弱的，难以变更的，并且没有明确的愿景和方向。</p>
<p>不充分了解系统中每个组件和模块的内部工作原理，就很难确定应用程序的体系结构特征。关于部署和维护的基本问题很难回答。eg：架构是否可以扩展？应用程序的性能特征是什么？应用程序响应变更的难易程度？<br>应用程序的部署特征是什么？体系结构的响应能力如何？</p>
<p>架构模式有助于定义应用程序的基本特征和行为。eg：一些架构模式适用于高度可伸缩，其它架构适用于高度敏捷的应用程序。了解每种架构模式的优点和缺点对于选型至关重要。</p>
<p>作为架构师，你必须始终证明您的体系结构决策是正确的，尤其是在选择特定的体系结构模式或方法时。</p>
<h2 id="-">分层架构</h2>
<p>最常见的架构模式是分层架构模式。分层架构和大多数公司的组织结构紧密匹配，使其成为大多数业务应用程序开发的自然选择。</p>
<p>分层体系架构中的组件被组织成水平层，每个层执行特定的功能。eg：表示逻辑和业务逻辑。</p>
<p>大多数分层架构的软件分为四层，表现层，业务层，持久化层，DB层。</p>
<p>每一层有特定的功能。eg：表现层会处理所有用户发起的请求。业务层执行请求关联的业务逻辑。</p>
<p>分层架构模式的一个强大特性是组件之间的关注点分离。</p>
<p>分层体系中的每个层都标记为已关闭，这是分层体系架构中非常重要的概念。封闭层意味着当请求从一层移动到另一层时，必须穿过它正下方的层。</p>
<p>为什么不允许表示层直接访问持久层或数据层呢？这个问题的答案在于隔离层的关键概念。</p>
<p>隔离层概念意味着在体系结构中的一个层所做的更改通常不会影响其它层的组件，该更改被隔离到该层中的组件，只有可能影响到关联层。如果不这样，就会产生一个组件之间有大量相互依赖关系的紧密耦合的应用程序，这种类型的体系结构很难改变。</p>
<p>隔离层的概念还意味着每个层独立于其它层，因此对体系结构中的其它层的内部工作知之甚少或一无所知。eg：考虑将JSP转换为JSF。</p>
<p>虽然封闭层有助于隔离，但是某些层是开放的是有意义的。eg：共享服务层添加到包含业务层中的公共服务组件（数据和字符串应用程序类，审核和日志类）。创建服务层通常是一个好主意，因为它将对共享服务的访问限制在业务层上。</p>
<p><img src="/note/assets/imgs/open-layer-software-arch.png" alt="开放分层结构图"></p>
<p>利用开放层和封闭层的概念有助于定义体系架构层和请求流之间的关系。</p>
<h3 id="-">分层结构特点</h3>
<p>分层结构是一种可靠的通用模式，当您不确定哪种体系结构最适合您的应用时，可以先采用此模式。</p>
<p>但有两个方面需要考虑。</p>
<p>首先要注意的是所谓的体系结构的反模式。eg：请求通过架构的多个层，但多个层只作简单的传递处理，在每一层执行很少或没有逻辑。</p>
<p>每一个分层结构都至少有一些场景属于反模式，关键是分析百分比。如果发现大部分请求都是简单得传递处理，可能需要考虑将一些体系架构层打开。</p>
<p>第二个考虑因素是分层架构倾向于单体应用程序。</p>
<h3 id="-">模式分析</h3>
<p>1、整体敏捷性：差，虽然有隔离层，但由于大多数实现的整体性以及通常的组件紧耦合，该体系结构中进行更改仍非常繁琐和耗时。</p>
<p>2、易于部署：差，部署可能会成为一个问题。组件的一个小更改可能需要重新部署整个应用程序。</p>
<p>3、可测试性：高，其它层可以被很容易模拟，使得此模式相对容易测试。</p>
<p>4、性能：低，由于必须通过体系结构的多个层来处理。</p>
<p>5、可伸缩性：低，由于该模式的紧密耦合和单体应用实现的趋势。可以通过将层拆分为单独的物理部署或将整个应用部署到多个节点，但总体而言，粒度太宽。</p>
<p>6、易于开发：高，该模式是众所周知的，并且实现起来也不复杂。</p>
<h2 id="-">事件驱动架构</h2>
<p>事件驱动的体系结构模式是一种流行的分布式异步体系结构模式，用于生成高度可伸缩的应用程序。</p>
<p>事件驱动的架构由高度解耦、单一用途的事件处理器组成，这些组件异步接收和处理事件。</p>
<p>事件驱动的体系结构由两个主要的拓扑组成，即中介和代理。需要通过中心中介者来协调事件中的多个步骤时，通常使用中介模式。不希望使用中心中介者的情况下，使用代理模式。</p>
<h3 id="-">中介拓扑</h3>
<p>中介拓扑对于具有多个步骤并需要某种级别的编排来处理事件的事件非常有用。eg：股票交易处理，首先验证该交易，检查股票交易是否符合各种合规规范，将交易分配给经纪人，计算佣金，最后与经纪人进行交易。这些步骤都需要某种程度的编排，以确定步骤的顺序，以及哪些步骤可以串行或并行完成。</p>
<p>中介拓扑中有四种主要组件：事件队列，事件中介，事件通道和事件处理器。</p>
<p>事件流从客户端向事件队列发送事件开始，事件队列将事件传输到事件中介。事件中介接收初始事件，并通过向事件通道发送额外的异步事件类协调该事件。以执行流程中的每个步骤。</p>
<p>事件处理器监听事件通道，从事件中介接收事件，并执行特定的业务逻辑来处理事件。</p>
<p><img src="/note/assets/imgs/mediator-event-software-arch.png" alt="开放分层结构图"></p>
<p>在事件驱动的体系结构中，通常有十几个到几百个事件队列。事件队列可以是消息队列，web服务端点或它们的任何组合。</p>
<p>两种类型的事件：初始事件和处理事件，初始事件是中介接收的原始事件，而处理事件是中介生成并由处理组件接收的事件。</p>
<p>事件中介组件负责编排初始事件中包含的步骤。事件中介并不实际执行处理初始事件所需的业务逻辑，相反，它知道处理初始事件所需的步骤。</p>
<p>事件中介使用事件通道将与初始事件中的每个步骤相关的特定事件异步传递给事件处理器。通道可以是消息队列或消息主题。消息主题广泛使用，因为消息主题可以被多个事件处理器订阅。</p>
<p>事件处理器组件包含处理事件所需的应用程序业务逻辑，事件处理器是自包含的，独立的，高度解耦的体系结构组件，在应用程序或系统中执行特定的任务。</p>
<p>事件处理器的组件粒度可以从细粒度到粗粒度不等，但是，一般每个事件处理器组件应该执行单个业务任务，而不依赖于其它事件处理器来完成特定的任务。</p>
<p>事件中介可以通过多种方式实现，作为一名架构师，你应该理解这些实现选项中的每一个，以确保为事件中介选择的解决方案符合您的需求。</p>
<p>最简单和最常见的实现是通过Spring intergration、Apache Cemel或Mule ESB等开源集成中心实现的。</p>
<p>这些开源集成集线器中的事件流通常通过Java代码或DSL实现。对于更复杂的中介和编排，您可以使用BPEL(Business-Process-Execution-Language)和BPEL引擎结合使用。</p>
<p>BPEL是一种标准的类XML的语言，它描述了处理初始事件所需的数据和步骤。对于需要更复杂的编排，你可以使用BPM流程管理器（BPM-Business-Process-Manager）。</p>
<h3 id="-">代理人拓扑</h3>
<p>代理拓扑与中介拓扑的不同之处在于没有中央事件中介器。相反，消息流通过轻量级消息代理以类似链的方式发布在事件处理器组件之间。</p>
<p>当你具有简单的事件处理流并且不希望中央事件处理业务流程时，此拓扑非常有用。</p>
<p>有两种基本的架构组件：1、代理组件；2、事件处理组件。</p>
<p>代理组件可以是集中式的或联合式的，并且包含事件流中使用的所有事件通道。代理组件中包含的事件通道可以是消息队列，消息主题。</p>
<p><img src="/note/assets/imgs/event-software-arch.png" alt="代理人结构图"></p>
<p>没有中心事件中介组件控制和协调初始事件，每个事件处理器组件负责处理一个事件，并可能发布另一个新事件，指示它刚刚执行的操作。</p>
<p><img src="/note/assets/imgs/event-chain-software-arch.png" alt="事件链结构图"></p>
<p>代理人拓扑主要是使用事件处理流来完成业务逻辑。很像接力赛跑。</p>
<h3 id="-">注意事项</h3>
<p>事件驱动的架构实现起来比较复杂，这主要是因为它的异步分布式特性。必须解决各种分布式体系结构问题。eg：远程可用性、缺乏响应性以及代理或中介失败时的代理重新连接逻辑。</p>
<p>另外一个问题是，单个业务流程缺乏原子事务。由于事件处理器组件是高度解耦和分布式的，因此在它们之间维护事务工作单元非常困难。</p>
<p>如果您发现需要在事件处理器之间分割单个工作单元，那么这种模式可能不适用于您的应用程序。</p>
<p>事件驱动的体系结构模式最困难的方面之一是事件处理器组件契约的创建、维护和治理。</p>
<h3 id="-">模式分析</h3>
<p>1、敏捷性：高，对变化的响应能力高，由于事件处理器是单一用途的，并且与其它事件处理器组件完全解耦。只对一个或几个事件处理器进行更改，不影响其它事件处理器。</p>
<p>2、部署容易：高，由于处理器组件的解耦，很容易部署。代理人模式比中介模式更好部署，因为中介组件可能依赖于事件处理器组件。</p>
<p>3、可测试性：低，虽然单个单元测试不是非常困难，但它确实需要某种专门的测试客户端或测试工具来生成事件。</p>
<p>4、性能：高，虽然由于涉及到所有的消息传递基础设施，但通常情况下，该模式通过其异步功能实现了高性能。执行解耦的并行异步操作的能力超过了对消息进行排队和消费的成本。</p>
<p>5、可伸缩性：高，可伸缩性是通过高度独立和解耦的事件处理器实现的。每个事件处理器可单独伸缩，从而实现细粒度的可伸缩性。</p>
<p>6、易于开发：低，由于模式的异步特性以及契约的创建，需要为无响应的事件处理器和失败的代理提供更高级的错误处理条件，开发可能会有些复杂。</p>
<h2 id="-">微内核架构</h2>
<p>微内核架构或插件架构是实现一种基于产品的应用模式的首选架构模式。软件产品指的是第三方打包并提供下载的应用程序，另外，许多公司也开发一些需要插件的内部应用程序。</p>
<p>这些软件产类的产品适合这个模式，微内核架构允许将附加的应用程序功能作为插件添加到核心应用程序中，从而提供扩展性以及功能隔离。</p>
<h3 id="-">模式说明</h3>
<p>主要包括两个架构组件：1、核心系统；2、插件模块。</p>
<p>传统上，微内核架构模式的核心系统包含使系统运行所需的最小功能。许多操作系统都是微内核的架构。</p>
<p>从业务应用程序的角度来看，核心系统通常被定义为通用业务逻辑，插件用于特殊情况，特殊规则或复杂条件处理的自定义代码。</p>
<p><img src="/note/assets/imgs/plugin-software-arch.png" alt="插件架构结构图"></p>
<p>插件模块是独立的组件，包含专门的处理，附加功能和自定义代码。通常，插件应该独立于其它插件，但是也可以设计需要其它插件的插件。但是，必须将插件之间的通信保持在最低限度，以此来避免依赖性问题。</p>
<p>核心系统需要知道哪些插件模块是可用的和如何获取插件。一般通过插件应用商店。</p>
<p>插件可以通过多种方式连接到核心系统，包括OSGI，消息传递、web服务，甚至点到点绑定。您使用的连接类型取决于您正在构建的应用程序类型（小产品或大型业务应用程序）和特定的需求（单部署或分布式部署）。</p>
<p>插件模块和核心系统之间的契约可以从标准契约到定制契约。如果是自定义契约，最好创建适配器层。在创建标准契约时，一定要记住一开始就创建版本控制策略。</p>
<h3 id="-">架构示例</h3>
<p>VSCode IDE是个很好的例子。下载基本的IDE只提供一个简单的编辑器，一旦您开始添加插件，它就会成为高度可定制且有用的产品。浏览器也是一个很好的例子。</p>
<p>对于大型商业应用呢？举一个保险公司理赔的例子。索赔处理是一个非常复杂的过程，每个州都有不同的规则和规定，另外每个国家也有不同的规则和规定。</p>
<p>大多数保险索赔应用程序利用大型而复杂的规则引擎来处理大部分这种复杂性，但后续维护和变更会遇到问题。利用微内核体系架构模式可以解决其中的许多问题。</p>
<p><img src="/note/assets/imgs/claim-plugin-software-arch.png" alt="保险理赔结构图"></p>
<p>关键点在于基于州的规则的处理和核心理赔系统是分离的，在不影响剩下系统的前提下可以添加，移除和修改插件。</p>
<h3 id="-">注意事项</h3>
<p>微内核体系结构模式的一个优点是，它可以嵌入或作为另一个架构模式的一部分使用。</p>
<h3 id="-">模式分析</h3>
<p>1、敏捷性：高，通过松散耦合的插件模块，可以很大程度上隔离和快速实现变更。</p>
<p>2、部署性：高，根据模式的实现方式，插件模块可以在运行时动态添加到核心系统，减少部署期间的停机时间。</p>
<p>3、可测试性：高，插件模块可以独立进行测试，并且可以很容易被核心系统模拟。</p>
<p>4、性能：高，虽然微内核架构本身并不适合高性能应用程序，但通常情况下，使用微内核体系架构的软件性能都很好，因为您可以自定义和简化应用程序，只包含用户需要的特性。</p>
<p>5、可伸缩性：低，大多数微内核体系是基于产品的，而且通常规模较小，所以它们是作为单个单元实现的，因此没有高度的可伸缩性。</p>
<p>6、易于开发：低，需要经过深思熟虑的设计和契约治理，因此实现起来相当复杂。契约版本控制，内部插件注册，插件粒度以及插件连接性的广泛选择都增加了复杂度。</p>
<h2 id="-">微服务架构</h2>
<p>微服务作为独立应用程序和面向服务的体系结构的一种可行替代方案，正在迅速获得业界的认可。</p>
<h3 id="-">架构说明</h3>
<p>架构的若干核心概念：1、独立部署单元；通过有效和精简的交付管道，优秀的可伸缩性以及应用程序和组件的高度解耦，可以更容易地进行部署。</p>
<p>最重要的概念可能是服务组件。它的粒度可以从单个模块到应用程序的很大一部分。设计正确的服务组件粒度级别是微服务体系结构中的最大挑战之一。</p>
<p><img src="/note/assets/imgs/service-software-arch.png" alt="微服务结构图"></p>
<p>微服务体系结构中的另一个关键概念是，它是一个分布式体系结构，这意味着在体系结构中的所有组件都完全解耦，通过远程访问协议进行访问。</p>
<p>单片应用程序通常由紧密耦合的组件组成，这些组件是单个可部署单元的一部分，这使得更改、测试和部署应用程序变得繁琐和困难。因此出现了大多数IT企业中常见的月度署模式。</p>
<p>微服务体系结构模式通过将应用程序分离为多个可部署单元来解决这些问题，这些单元可以独立于其它服务组件进行开发、测试和部署。</p>
<p>另外一个演化路径是SOA的应用程序所发现的问题。尽管SOA非常强大，提供了无与伦比的抽象、异构连接、服务编排，以及将业务目标和IT功能相一致的承诺，但它非常复杂，昂贵，普遍难以理解和实现，并且对于大多数应用程序来说过于强大。微服务体系结构通过简化服务的概念、消除编排需求以及简化对服务组件的连接性和访问性来解决这种复杂性。</p>
<h3 id="-">架构拓扑结构</h3>
<p>有三个最常见和最流行的拓扑：1、基于API的拓扑；2、基于rest的应用程序拓扑；3、集中式消息传递拓扑。</p>
<p>API的拓扑，网站比较常见。</p>
<p><img src="/note/assets/imgs/api-service-software-arch.png" alt="API的结构图"></p>
<p>应用程序拓扑，和api拓扑的不同是，这些服务组件倾向于更大、更粗粒度，并代表整个业务应用程序的一部分。对于复杂度比较低的中小型业务应用程序来说很常见。</p>
<p>集中式消息拓扑，不同的是使用了一个轻量级的集中消息代理，而不是使用REST进行远程访问。</p>
<p>通常出现在较大的业务应用程序或需要对用户界面和服务组件之间的传输层进行更复杂控制的应用程序中。优点是高级队列机制，异步消息传递，监视，错误处理以及更好的负载平衡和可伸缩性。</p>
<p><img src="/note/assets/imgs/center-msg-service-software-arch.png" alt="Center-Message-Service的结构图"></p>
<h3 id="-">避免依赖关系和业务流程</h3>
<p>主要挑战之一是确定服务组件的正确粒度级别。如果服务组件粒度太粗，可能无法反应这个架构代理的好处(部署性，可伸缩性，可测试性，松耦合)。然而过于细粒度的服务组件将导致服务编排需求，并引入SOA的复杂性。</p>
<p>如果你发现需要在应用程序的用户界面或API层中编排服务组件，那么服务组件就太细粒度了。</p>
<p>如果你发现需要在服务组件之间执行服务间通信来处理单个请求，要么你的服务组件粒度太细，要么从业务功能的角度来看它们没有被正确地区分。</p>
<p>服务间通信可能迫使组件之间产生不希望的耦合。共享数据库可以处理信息需求，但共享功能呢？跨组件之间复制共享的功能违反DRY原则。</p>
<p>在大多数应用程序中，会重复一小部分业务逻辑冗余，这是必要的牺牲。</p>
<p>如果您发现无论服务组件粒度的级别如何，仍然无法避免服务组件编排，这可能说明您的应用程序不适合该架构。</p>
<p>由于此模式的分布式特性，跨服务组件之间维护单个事务工作单元非常困难。需要某种事务补偿性框架来回滚事务，这给这个相对简单而优雅的体系架构模式增加了很大的复杂性。</p>
<h3 id="-">注意事项</h3>
<p>由于主要的应用程序组件被分割成更小的、单独部署的单元，使用微服务体系结构模式构建的应用程序通常更健壮，提供更好的可伸缩性，并且更容易支持持续交付。</p>
<p>这种模式的另一个优点是，它提供了进行实时生产部署的能力，从而大大减少了对传统的每月或周末“大爆炸”生产部署的需求。</p>
<p>由于微服务体系结构模式是一种分布式体系结构，它与事件驱动体系结构模式存在一些相同的复杂问题，包括契约的创建、维护和管理、远程系统可用性、以及远程访问认证和授权。</p>
<h3 id="-">架构分析</h3>
<p>1、敏捷性，高，更改通常被隔离到单个服务组件。组件之间的耦合很松散。</p>
<p>2、可部署性，高，具有细粒度和独立的特性，部署特性非常高。热部署和失败的部署能够更快恢复。</p>
<p>3、可测试性，高，可以确定测试的范围，从而实现更有针对性的测试工作。</p>
<p>4、性能，低，由于分布式特性，并不适合高性能应用程序。</p>
<p>5、可伸缩性，高，每个服务组件都可以单独伸缩，从而允许对应用程序进行微调伸缩。</p>
<p>6、易于开发，高，由于功能被隔离到独立的和不同的服务组件中，开发变得更容易，因为范围更小和隔离。减少了开发人员团队之间的沟通和协调。</p>
<h2 id="-">空间架构</h2>
<p>大多数基于Web的业务应用程序遵循相同的通用请求流，来自浏览器的请求访问Web服务器，然后访问应用服务器，最后访问数据库服务器。随着用户负载的增加，瓶颈开始出现。</p>
<p>在具有非常大的并发用户负载的应用程序中，数据库能并发处理多少事务是最终的限制因素。虽然有各种缓存技术和数据库扩展产品有助于解决这些问题，但事实上，在极端负载下扩展应用程序仍然是一个非常困难的事情。</p>
<p>基于空间的体系结构是专门设计来解决可伸缩性和并发性的问题的。对于具有可变且不可预测并发用户数的应用程序，它也有一种有用的体系结构模式。</p>
<h3 id="-">架构说明</h3>
<p>基于空间的模式也称为云架构模式最大限度地减少了限制应用程序伸缩性的因素，这种模式的名称来源于元组空间的概念，即分布式共享内存的概念。</p>
<p>高可伸缩性是通过消除中央数据库约束和使用赋值的内存数据网格来实现的。应用程序数据保存在内存中，并在所有活动的处理单元之间复制。</p>
<p>处理单元可以随着用户负载的增加和减少而动态地启动和关闭，从而实现可变的可伸缩性。</p>
<p>大多数符合此模式的应用程序都是标准的网站。eg：竞价拍卖网站。</p>
<p>这个结构有两个结构组件：1、处理单元；2、虚拟中间件。</p>
<p>处理单元通常包含应用程序模块，以及内存中的数据网格和用于故障转移的可选异步持久存储。它还包含一个复制引擎，虚拟中间件使用该引擎将一个处理单元所做的数据更改复制到其它活动处理单元。</p>
<p><img src="/note/assets/imgs/space-based-software-arch.png" alt="基于空间的架构"></p>
<p>虚拟中间件组件处理管理和通信。</p>
<p>虚拟组件的本质是体系结构的控制器，管理请求、会话、数据复制、分布式请求处理和处理单元部署。</p>
<p>虚拟中间件中有四个主要的体系结构组件：消息传递网格、数据网格、处理网格和部署管理器。</p>
<h2 id="-">参考文档</h2>
<p><a href="https://orkhanscience.medium.com/software-architecture-patterns-5-mins-read-e9e3c8eb47d2">https://orkhanscience.medium.com/software-architecture-patterns-5-mins-read-e9e3c8eb47d2</a></p>
<p><a href="https://www.oreilly.com/content/software-architecture-patterns/">https://www.oreilly.com/content/software-architecture-patterns/</a></p>
</body>
</html>
