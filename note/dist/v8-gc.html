<!DOCTYPE html>
<html>
<head>
  <title>V8中的垃圾回收</title>
  <link rel="stylesheet" href="/note/note.css?ts=1649777290912">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="v8-">V8中的垃圾回收</h1>
<h2 id="v8-">V8是什么</h2>
<p>V8是一个JS运行时引擎，编译并执行你的JS代码。V8有一个代际的，stop-the-world的垃圾回收器。</p>
<h2 id="-">垃圾回收器是什么</h2>
<p>垃圾回收的要点是能够管理特定程序的内存使用情况。JS缺乏访问内存的特定接口，这基本意味着程序中的内存管理权限都将传给V8。</p>
<p>因为内存资源是有限的，垃圾回收期的工作是遍历内存中分配的对象并确定它们是死的还是活的，死去的对象会被删除，而内存会被分配回堆中。</p>
<p>堆是一个非结构化区域，对象在其中分配内存，这种分配是动态的，因为对象的大小/生命周期/数量是未知的，需要在运行时进行分配和回收内存。</p>
<p>堆直接与调用堆栈一起工作，因为堆栈中显示的对象需要内存分配。</p>
<h2 id="dead-or-alive-">Dead or alive?</h2>
<p>对象是否Alive的基本检查是执行代码的程序是否可以访问它，最容易到达的对象可能是在根作用域中定义的对象。</p>
<p>一些C++的bindings或Web-APIS也是根的一部分，所以你可以直接访问setInterval。</p>
<p>可访问性也可以被认为是另一个对象或根是否可以直接或间接地访问该对象，如果可访问，内存就不会回收。</p>
<h2 id="-">如何进行垃圾回收？</h2>
<p>当你创建新对象，或创建新指针(JS没有指针的概念，主要指包装器对象)，</p>
<p>堆中有一堆不同的空间用于不同类型的对象，它将像这样组织。为了进行垃圾回收，V8将堆分为两个部分：新生代和旧生代。</p>
<p>当你像V8申请内存时，V8会在新生代中申请内存，随着你不断申请内存，最终会耗尽内存，这时V8不得不进行垃圾回收。</p>
<p>新创建的对象会非常快地分配，并定期清理，以删除不可访问的对象。一旦对象存活了几次(准确得说是两次)，它们就会被提升到旧生代空间中，当空间满时，就会在一个单独的循环中回收垃圾。</p>
<p>较老的对象是那些在一次以上的垃圾清理中幸存下来的对象，这意味着它们一直被其它对象引用，并且仍然需要分配内存，它们通常不会引用较年轻的对象，但会引用老对象。缺少代与代之间的相互引用，使得每个系列都有一个更干净的清扫。</p>
<h2 id="-v8-">深入了解V8垃圾回收引擎</h2>
<p>V8使用分代垃圾收集器，将JS堆拆分为新生代和老生代。大多数对象存活时间很短，这种分代策略使垃圾收集器能够在较小的新生代中执行常规的、较短的垃圾收集，而不必跟踪旧生代中的对象。</p>
<p>V8的新生代使用半空间策略管理，新对象在活动的半空间中申请内存。当半空间满时，整理操作会将live对象搬到另一半空间。被搬过一次的对象被认为是长期对象，会被搬到旧生代中。</p>
<p>一旦live的对象搬到了新的半空间，新的半空间被设置为活动的旧空间，旧的半空间的数据会被丢弃。</p>
<p>整理操作的耗时取决于新生代中live对象的大小。如果大多数对象不可访问，耗时会小于1ms。然而，如果大多数对象是live的，耗时会显著提高。</p>
<p>当旧生代的live对象们的大小超过了限制，V8会执行整个堆的垃圾回收。旧生代使用带有若干优化的mark-and-sweep收集器来改善延迟和内存消耗。</p>
<p>标记延迟取决于必须标记的live对象的数量，对于大型web应用程序，标记整个堆可能需要超过100ms。为了不长时间阻塞主线程，V8会分批多次标记。</p>
<p>标记完成后，通过扫描整个旧生代内存，空闲内存将再次可用，此任务由专门清理器线程并发执行。</p>
<p>最后，执行内存压缩以减少旧生代的内存碎片，这个任务非常耗时，只在存在内存碎片问题时才执行。</p>
<p>总结：主要有4种垃圾回收任务：</p>
<p>1、新生代整理，速度非常快。</p>
<p>2、标记，可以增量分批标记，时长跟必须标记的live对象的数量有关。</p>
<p>3、全堆垃圾回收，耗时比较长。</p>
<p>4、带内存压缩的全堆垃圾回收，耗时比较长。</p>
<p>V8会尽量在空闲时去执行这些垃圾回收任务，但是也会有一个deadline。</p>
<p>V8引擎会按照应用申请内存的速度来分析，在下一次申请内存时是否会填满新生代，如果会，新生代会执行整理任务。同时，V8页会记录整理新生代的平均耗时来预测未来整理的耗时。</p>
<p>当旧生代中的live对象们的大小快达到堆的限制，增量标记任务会开始。增量标记任务的耗时同需要标记的内存大小成正比。</p>
<p>如果旧生代几乎已满，并且估计提供给任务的截止时间足够长，则将在空闲任务期间调度完整的垃圾收集。收集暂停时间是根据标记速度乘以分配的对象数量来预测的。只有当网页闲置了相当长的一段时间，才会执行带有附加压缩的完整垃圾收集。</p>
<p>空闲时间给更积极的垃圾回收策略提供了机会。Chrome-45利用了这点，大大改善了前台标签所消耗的内存。eg：相比Chrome43，Chrome45在空闲时间，堆内存使用量降低了45%。</p>
<h2 id="-">参考文档</h2>
<p><a href="https://v8.dev/blog/free-garbage-collection">https://v8.dev/blog/free-garbage-collection</a></p>
<p><a href="https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8">https://medium.com/@_lrlna/garbage-collection-in-v8-an-illustrated-guide-d24a952ee3b8</a></p>
</body>
</html>
