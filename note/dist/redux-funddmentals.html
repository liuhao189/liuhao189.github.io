<!DOCTYPE html>
<html>
<head>
  <title>Redux基本原理</title>
  <link rel="stylesheet" href="/note/note.css?ts=1644079267908">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="redux-">Redux基本原理</h1>
<h2 id="-redux-">第一部分：Redux概述</h2>
<p>What：Redux是一个使用叫actions的事件来管理和更新应用状态的类库。它作为整个应用程序状态的集中式存储，其规则确保状态只能以可预测的方式更新。</p>
<p>Why：Redux提供的模式和工具使您更容易理解应用程序中的状态更新的时间、地点、原因和方式，以及发生这些更改时应用程序需要做的逻辑处理。</p>
<p>When：Redux也有利弊，需要学习新概念，书写更多的代码，添加一些间接方法，并要求你遵循某些限制。是短期生产力和长期生产力之间的权衡。</p>
<p>在下列场景下更有用：</p>
<p>1、有大量的应用程序状态需要在应用程序的大量地方。</p>
<p>2、应用程序状态会高频更新。</p>
<p>3、更新状态的逻辑很复杂。</p>
<p>4、多人开发，中大型代码库。</p>
<h3 id="redux-">Redux类库和工具</h3>
<p>Redux是一个独立的JS类库，通常它会和其它类库配合使用。React-redux是官方库。Redux-Toolkit是我们推荐的编写Redux逻辑需要使用的类库，包含了很多有用的函数。React-DevTools-Extension展示了状态的变更历史。</p>
<h3 id="redux-">Redux基本概念</h3>
<h4 id="redux-store">Redux Store</h4>
<p>Store包含了应用的全局状态。</p>
<p>Store的特点：</p>
<p>1、不可直接修改Store中的状态。</p>
<p>2、导致状态更新的唯一方法是创建一个普通的Action对象，该对象描述应用程序中发生的事情。然后将该Action Dispatch到Store中。</p>
<p>3、在Dispatch时，Store会运行root reducer函数，并让它根据old state和Action来计算new state。</p>
<p>4、最后，Store通知订阅者状态已经更新，因此UI可以用新数据更新。</p>
<p>UI的作用：在应用中，UI应该在屏幕上展示应用状态。</p>
<h4 id="data-flow">Data Flow</h4>
<p>1、Action做为UI的响应被Dispatch出来。</p>
<p>2、Store执行Reducer函数来计算新状态，然后通知订阅者。</p>
<p>3、UI渲染收到状态变更通知展示新状态。</p>
<h2 id="-">第二部分：概念和数据流转</h2>
<h3 id="-">背景概念</h3>
<h4 id="-">状态管理</h4>
<p>React管理counter的简单组件形式：自包含应用，包含了state，view和actions。</p>
<p>单向数据流：</p>
<p>1、状态描述应用在特定时间点的状态；</p>
<p>2、UI渲染基于state。</p>
<p>3、当一些事件发生，state根据发生了什么开始更新。</p>
<p>4、UI根据new state来重新渲染。</p>
<p>当多个组件需要共享和使用相同的状态时，简单性就会崩溃。有时，可以通过提升状态到父组件来解决，但这并不总是有帮助的。</p>
<p>通过定义和分离状态管理中涉及到的概念，并强制实施在视图和状态之间保持独立性的规则，我们为代码提供了更多的结构和可维护性。</p>
<h4 id="-">不可变性</h4>
<p>JS的对象和数组都是不可变的，为了更新数据，需要拷贝已存在的对象和数组，然后更改拷贝后的数据。</p>
<p>我们可以使用对象和数组的展开运算符，或某些方法来返回拷贝对象。</p>
<p>Redux期望所有的更新都是不可变更新。</p>
<p>这意味着你需要不断地创造新值并替换旧值，而不是使用传统的变量。</p>
<p>GiveAwesomePowers(person)：对象的内部结构发生了变化，但对象引用没有发生变化。</p>
<p>纯函数概念：1、一个纯函数有相同的输入时，必须有相同的输出；2、一个纯函数不能有副作用。</p>
<p>副作用概念：1、修改函数输入参数；2、修改函数外的其它状态，eg：全局变量；3、调用API；4、console.log；5、Math.random。</p>
<p>JS数组的变异方法：push，pop，shift，unshift，sort，reverse，splice。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">//copy的方法</span>
<span class="kd">let</span>  <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">copy1</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">copy2</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">copy3</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">();</span>
</pre></div>

</code></pre>
<p>giveAwesomePowers的纯函数版本，先拷贝person，然后再添加新属性。</p>
<p>React更喜欢不变性：在React中，不要直接改变state和props。</p>
<p>React中：直接改变state可能导致奇怪的bug，同时使组件难以优化。</p>
<p>提高组件性能的通用手法是使组件变纯，组件的重新渲染只是当它的props改变，而不是每次父组件重新渲染时。</p>
<p>不可变性对纯函数很重要：默认情况下，React组件在父组件重渲染时，或使用setState时会重新渲染。</p>
<p>继承了React.PureComponent的组件只在它的props改变或setState时，重新渲染，是常见的性能优化手段。</p>
<p>JS的对象和数组直接使用===，判断的是引用相等。</p>
<p>为什么不遍历检查相等？根据对象的大小，遍历检查的时间差异很大。而引用相等判断会在常量时间内完成。</p>
<p>React的setState方法会浅拷贝state，然后和参数合并来生成新的state。</p>
<h5 id="-">常见场景</h5>
<p>改变对象：利用展开运算符，多层对象需要多层展开。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">{</span>
  <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
  <span class="nx">prop</span><span class="o">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">age</span><span class="o">++</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>插入数组：利用展开运算符。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">[</span>
  <span class="nx">newItem</span><span class="p">,</span>
  <span class="p">...</span><span class="nx">state</span>
<span class="p">]</span>
</pre></div>

</code></pre>
<p>数组中item变更：map方法返回新数组即可。</p>
<p>数组中插入item：先slice拷贝，然后splice。</p>
<p>数组中删除item：使用filter即可。</p>
<h5 id="-immer-">使用Immer类库更新</h5>
<p>Immer让你可以用常见的手法来更新对象。Immer会帮你处理为不可变更新。</p>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i immer
</pre></div>

</code></pre>
<p>然后引入produce方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">immerifiedReducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;ravenclaw&#39;</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">produce</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">draft</span><span class="p">.</span><span class="nx">houses</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">points</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>produce方法返回了一个柯里化的方法，所以setState的函数版本可以直接传递一个参数。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">produce</span><span class="p">(</span><span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">draft</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}));</span>
</pre></div>

</code></pre>
<p>Immer：数据中未更改的部分不需要复制，而是在内存中与相同状态的旧版本共存。使用Immer时，会对草稿对象进行更改，该对象会记录更改并负责创建必要的副本。</p>
<h5 id="immer-">Immer的原理</h5>
<p>草稿是当前状态的代理，Immer会将你对草稿的操作记录下来，一旦你的更新方法运行结束，Immer会根据操作记录和old state来生成nextState。</p>
<h3 id="redux-">Redux的专业术语</h3>
<h4 id="actions">Actions</h4>
<p>普通的JS对象，type字段表示类型。可以理解为应用中发生的事件。</p>
<p>type一般是domain/eventName格式的，额外的信息存储在payload中。</p>
<h4 id="reducers">Reducers</h4>
<p>Reducer是一个接受当前状态和一个action对象的函数，返回新的状态。(state,action) =&gt; newState。可以理解为事件处理器。</p>
<p>Reducer需要是纯函数，只基于state和action计算newState，不允许改变已有的state，只能做不可变的更新。不能有异步逻辑和副作用。</p>
<h4 id="store">Store</h4>
<p>集中式的状态存储的地方，有getState方法可以获取当前数据。</p>
<h4 id="dispatch">Dispatch</h4>
<p>store有一个dispatch方法，只有调用该方法才能更新state。可以理解为事件生成器。</p>
<h4 id="selectors">Selectors</h4>
<p>Selectors是知道如何从store中提取特定信息的函数。可以减少重复的提取state的逻辑。</p>
<h3 id="-">核心概念和原则</h3>
<h4 id="-">数据的唯一来源</h4>
<p>应用的全部状态应该存储到全局唯一的store中。</p>
<h4 id="-">状态是只读的</h4>
<p>只能使用dispatch action来更新数据。UI不会直接写数据，action是普通的JS对象，可以被logged，序列化存储，方便调试和测试。</p>
<h4 id="-reducer-">用纯reducer函数用来更新</h4>
<p>更好理解。</p>
<h4 id="redux-">Redux应用的数据流</h4>
<p>初始化：</p>
<p>1、Redux Store使用root reducer方法来初始化。并生成初始state。</p>
<p>2、UI组件根据当前的状态渲染，同时订阅了store的更新事件。</p>
<p>更新：</p>
<p>1、app中发生了事件，app dispatch了action到Store。</p>
<p>2、store执行reducer函数，reducer函数根据当前状态和action来计算newState。</p>
<p>3、store通知UI状态更新。UI组件检查自身关注的状态是否改变。</p>
<h2 id="-state-action-reducer">第三部分，State，Action和Reducer</h2>
<h3 id="-state-">设计State的值</h3>
<p>React和Redux的核心原则之一是UI应该基于你的状态。</p>
<p>核心的是：todoList和当前的filter选项。todoItem包含name，completed status，id，color分类。Filter包含color和status。</p>
<p>todos是应用级别的state，然而filter选型是UI级别的state。</p>
<h3 id="-state-">设计state结构</h3>
<p>Redux中，我们的状态一般使用普通的JS对象和数组来构成。</p>
<h3 id="-actions">设计Actions</h3>
<p>描述当前发送了什么事件的action。</p>
<p>1、add，toggle，select color，delete，mark all completed，clear all。。。</p>
<h3 id="-reducers">写Reducers</h3>
<p>Redux App只有一个reducer函数，即root reducer。</p>
<p>Redux的目标之一是让你的代码可预测，当一个函数的输出只由输入参数决定，代码的工作方式和相关的测试会很容易。</p>
<h3 id="-reducers">分开Reducers</h3>
<p>Redux的reducers一般按照它们更新的state的部分来分开维护。</p>
<p>我们推荐基于功能来组织你的redux代码。同功能模块的redux代码经常分离到一个以slice结尾的文件中。</p>
<h3 id="-reducers">结合Reducers</h3>
<p>combineReducers方法。</p>
<h2 id="-store">第四部分，Store</h2>
<p>Store负责的部分：</p>
<p>1、将当前应用程序状态存储在内部。</p>
<p>2、允许使用store.getState来获取当前状态。</p>
<p>3、允许使用store.dispatch(action)来更新状态。</p>
<p>4、允许使用store.subscribe来注册回调函数。</p>
<p>5、允许使用store.subscribe返回的unsubscribe函数来注销回调。</p>
<h3 id="-store">创建Store</h3>
<p>主要使用createStore方法来创建Store。createStore的第二个参数可以接受preloadedState。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;redux&#39;</span><span class="p">;</span>
</pre></div>

</code></pre>
<h3 id="redux-store-">Redux Store的代码实现</h3>
<p>store有state和reducer的属性存储。getState返回当前的state。subscribe保存一个监听函数数组。dispatch调用reducer，然后保存状态，最后一次调用监听器。</p>
<p>store在初始化时dispatch了一个action，来初始化reducer提供的状态。</p>
<p>store的API包含{dispatch, subscribe, getState}。</p>
<h3 id="-store">配置Store</h3>
<p>Store允许使用插件来增强功能。插件可以提供自身版本的dispatch，getState和subscribe函数。</p>
<p>Redux里有一个compose方法来混合多个插件功能。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">composedEnhancer</span> <span class="o">=</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">sayHiDispatch</span><span class="p">,</span> <span class="nx">includeMeaningOfLife</span><span class="p">);</span>
<span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">composedEnhancer</span><span class="p">);</span>
</pre></div>

</code></pre>
<h3 id="-">中间件</h3>
<p>插件的功能非常强大，因为插件可以重写dispatch，getState和subscribe。但是大多数情况下，我们只需要自定义我们的dispatch的表现。</p>
<p>Redux允许使用一种特殊的插件来自定义dispatch，这种特殊的插件叫做middleware。</p>
<p>中间件的最佳使用方式是链式调用。</p>
<h3 id="-">使用中间件</h3>
<p>主要使用applyMiddleware方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span><span class="nx">createStore</span><span class="p">,</span> <span class="nx">applyMiddleware</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;redux&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">middlewareEnhancer</span> <span class="o">=</span> <span class="nx">applyMiddleware</span><span class="p">(</span><span class="nx">print1</span><span class="p">,</span> <span class="nx">print2</span><span class="p">,</span> <span class="nx">print3</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">,</span> <span class="nx">middlewareEnahancer</span><span class="p">)</span><span class="c1">//如果没有初始化状态，插件可以是第二个参数。</span>
</pre></div>

</code></pre>
<p>Middleware围绕store的dispatch方法形成了一个pipeline。跟recuder不同的是，middleware可以包含副作用。</p>
<h3 id="-">写自定义的中间件</h3>
<p>Redux的middleware一般包含一系列的三层嵌套函数。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">exampleMiddleware</span><span class="p">(</span><span class="nx">storeAPI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">wrapDispatch</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">handleAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//可以使用storeAPI.dispatch(action)来重启流水线</span>
      <span class="c1">//可以使用storeAPI.getState来获取状态</span>
      <span class="c1">//可以使用next(action)来执行流水线的下一个方法</span>
      <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>只有handleAction的函数代码在action被dispatched时被调用。</p>
<h3 id="middleware-">Middleware的使用场景</h3>
<p>middleWare可以做很多事情。</p>
<p>1、打印一些日志。</p>
<p>2、设置定时器。</p>
<p>3、调用async的API。</p>
<p>4、修改action。</p>
<p>5、暂停action或stop action。</p>
<p>中间件旨在包含具有副作用的逻辑。此外，中间件可以让dispatch接受不是普通对象的action。</p>
<h3 id="redux-devtools">Redux DevTools</h3>
<h2 id="-">参考文档</h2>
<p><a href="https://redux.js.org/tutorials/fundamentals/part-1-overview">https://redux.js.org/tutorials/fundamentals/part-1-overview</a></p>
<p><a href="https://daveceddia.com/react-redux-immutability-guide/">https://daveceddia.com/react-redux-immutability-guide/</a></p>
<p><a href="https://daveceddia.com/why-not-modify-react-state-directly/">https://daveceddia.com/why-not-modify-react-state-directly/</a></p>
</body>
</html>
