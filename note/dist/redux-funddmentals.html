<!DOCTYPE html>
<html>
<head>
  <title>Redux基本原理</title>
  <link rel="stylesheet" href="/note/note.css?ts=1645290074658">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="redux-">Redux基本原理</h1>
<h2 id="-redux-">第一部分：Redux概述</h2>
<p>What：Redux是一个使用叫actions的事件来管理和更新应用状态的类库。它作为整个应用程序状态的集中式存储，其规则确保状态只能以可预测的方式更新。</p>
<p>Why：Redux提供的模式和工具使您更容易理解应用程序中的状态更新的时间、地点、原因和方式，以及发生这些更改时应用程序需要做的逻辑处理。</p>
<p>When：Redux也有利弊，需要学习新概念，书写更多的代码，添加一些间接方法，并要求你遵循某些限制。是短期生产力和长期生产力之间的权衡。</p>
<p>在下列场景下更有用：</p>
<p>1、有大量的应用程序状态需要在应用程序的大量地方。</p>
<p>2、应用程序状态会高频更新。</p>
<p>3、更新状态的逻辑很复杂。</p>
<p>4、多人开发，中大型代码库。</p>
<h3 id="redux-">Redux类库和工具</h3>
<p>Redux是一个独立的JS类库，通常它会和其它类库配合使用。React-redux是官方库。Redux-Toolkit是我们推荐的编写Redux逻辑需要使用的类库，包含了很多有用的函数。React-DevTools-Extension展示了状态的变更历史。</p>
<h3 id="redux-">Redux基本概念</h3>
<h4 id="redux-store">Redux Store</h4>
<p>Store包含了应用的全局状态。</p>
<p>Store的特点：</p>
<p>1、不可直接修改Store中的状态。</p>
<p>2、导致状态更新的唯一方法是创建一个普通的Action对象，该对象描述应用程序中发生的事情。然后将该Action Dispatch到Store中。</p>
<p>3、在Dispatch时，Store会运行root reducer函数，并让它根据old state和Action来计算new state。</p>
<p>4、最后，Store通知订阅者状态已经更新，因此UI可以用新数据更新。</p>
<p>UI的作用：在应用中，UI应该在屏幕上展示应用状态。</p>
<h4 id="data-flow">Data Flow</h4>
<p>1、Action做为UI的响应被Dispatch出来。</p>
<p>2、Store执行Reducer函数来计算新状态，然后通知订阅者。</p>
<p>3、UI渲染收到状态变更通知展示新状态。</p>
<h2 id="-">第二部分：概念和数据流转</h2>
<h3 id="-">背景概念</h3>
<h4 id="-">状态管理</h4>
<p>React管理counter的简单组件形式：自包含应用，包含了state，view和actions。</p>
<p>单向数据流：</p>
<p>1、状态描述应用在特定时间点的状态；</p>
<p>2、UI渲染基于state。</p>
<p>3、当一些事件发生，state根据发生了什么开始更新。</p>
<p>4、UI根据new state来重新渲染。</p>
<p>当多个组件需要共享和使用相同的状态时，简单性就会崩溃。有时，可以通过提升状态到父组件来解决，但这并不总是有帮助的。</p>
<p>通过定义和分离状态管理中涉及到的概念，并强制实施在视图和状态之间保持独立性的规则，我们为代码提供了更多的结构和可维护性。</p>
<h4 id="-">不可变性</h4>
<p>JS的对象和数组都是不可变的，为了更新数据，需要拷贝已存在的对象和数组，然后更改拷贝后的数据。</p>
<p>我们可以使用对象和数组的展开运算符，或某些方法来返回拷贝对象。</p>
<p>Redux期望所有的更新都是不可变更新。</p>
<p>这意味着你需要不断地创造新值并替换旧值，而不是使用传统的变量。</p>
<p>GiveAwesomePowers(person)：对象的内部结构发生了变化，但对象引用没有发生变化。</p>
<p>纯函数概念：1、一个纯函数有相同的输入时，必须有相同的输出；2、一个纯函数不能有副作用。</p>
<p>副作用概念：1、修改函数输入参数；2、修改函数外的其它状态，eg：全局变量；3、调用API；4、console.log；5、Math.random。</p>
<p>JS数组的变异方法：push，pop，shift，unshift，sort，reverse，splice。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">//copy的方法</span>
<span class="kd">let</span>  <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">copy1</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">copy2</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">copy3</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">();</span>
</pre></div>

</code></pre>
<p>giveAwesomePowers的纯函数版本，先拷贝person，然后再添加新属性。</p>
<p>React更喜欢不变性：在React中，不要直接改变state和props。</p>
<p>React中：直接改变state可能导致奇怪的bug，同时使组件难以优化。</p>
<p>提高组件性能的通用手法是使组件变纯，组件的重新渲染只是当它的props改变，而不是每次父组件重新渲染时。</p>
<p>不可变性对纯函数很重要：默认情况下，React组件在父组件重渲染时，或使用setState时会重新渲染。</p>
<p>继承了React.PureComponent的组件只在它的props改变或setState时，重新渲染，是常见的性能优化手段。</p>
<p>JS的对象和数组直接使用===，判断的是引用相等。</p>
<p>为什么不遍历检查相等？根据对象的大小，遍历检查的时间差异很大。而引用相等判断会在常量时间内完成。</p>
<p>React的setState方法会浅拷贝state，然后和参数合并来生成新的state。</p>
<h5 id="-">常见场景</h5>
<p>改变对象：利用展开运算符，多层对象需要多层展开。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">{</span>
  <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
  <span class="nx">prop</span><span class="o">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">age</span><span class="o">++</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>插入数组：利用展开运算符。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">[</span>
  <span class="nx">newItem</span><span class="p">,</span>
  <span class="p">...</span><span class="nx">state</span>
<span class="p">]</span>
</pre></div>

</code></pre>
<p>数组中item变更：map方法返回新数组即可。</p>
<p>数组中插入item：先slice拷贝，然后splice。</p>
<p>数组中删除item：使用filter即可。</p>
<h5 id="-immer-">使用Immer类库更新</h5>
<p>Immer让你可以用常见的手法来更新对象。Immer会帮你处理为不可变更新。</p>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i immer
</pre></div>

</code></pre>
<p>然后引入produce方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">immerifiedReducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;ravenclaw&#39;</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">produce</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">draft</span><span class="p">.</span><span class="nx">houses</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">points</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>produce方法返回了一个柯里化的方法，所以setState的函数版本可以直接传递一个参数。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">produce</span><span class="p">(</span><span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">draft</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}));</span>
</pre></div>

</code></pre>
<p>Immer：数据中未更改的部分不需要复制，而是在内存中与相同状态的旧版本共存。使用Immer时，会对草稿对象进行更改，该对象会记录更改并负责创建必要的副本。</p>
<h5 id="immer-">Immer的原理</h5>
<p>草稿是当前状态的代理，Immer会将你对草稿的操作记录下来，一旦你的更新方法运行结束，Immer会根据操作记录和old state来生成nextState。</p>
<h3 id="redux-">Redux的专业术语</h3>
<h4 id="actions">Actions</h4>
<p>普通的JS对象，type字段表示类型。可以理解为应用中发生的事件。</p>
<p>type一般是domain/eventName格式的，额外的信息存储在payload中。</p>
<h4 id="reducers">Reducers</h4>
<p>Reducer是一个接受当前状态和一个action对象的函数，返回新的状态。(state,action) =&gt; newState。可以理解为事件处理器。</p>
<p>Reducer需要是纯函数，只基于state和action计算newState，不允许改变已有的state，只能做不可变的更新。不能有异步逻辑和副作用。</p>
<h4 id="store">Store</h4>
<p>集中式的状态存储的地方，有getState方法可以获取当前数据。</p>
<h4 id="dispatch">Dispatch</h4>
<p>store有一个dispatch方法，只有调用该方法才能更新state。可以理解为事件生成器。</p>
<h4 id="selectors">Selectors</h4>
<p>Selectors是知道如何从store中提取特定信息的函数。可以减少重复的提取state的逻辑。</p>
<h3 id="-">核心概念和原则</h3>
<h4 id="-">数据的唯一来源</h4>
<p>应用的全部状态应该存储到全局唯一的store中。</p>
<h4 id="-">状态是只读的</h4>
<p>只能使用dispatch action来更新数据。UI不会直接写数据，action是普通的JS对象，可以被logged，序列化存储，方便调试和测试。</p>
<h4 id="-reducer-">用纯reducer函数用来更新</h4>
<p>更好理解。</p>
<h4 id="redux-">Redux应用的数据流</h4>
<p>初始化：</p>
<p>1、Redux Store使用root reducer方法来初始化。并生成初始state。</p>
<p>2、UI组件根据当前的状态渲染，同时订阅了store的更新事件。</p>
<p>更新：</p>
<p>1、app中发生了事件，app dispatch了action到Store。</p>
<p>2、store执行reducer函数，reducer函数根据当前状态和action来计算newState。</p>
<p>3、store通知UI状态更新。UI组件检查自身关注的状态是否改变。</p>
<h2 id="-state-action-reducer">第三部分，State，Action和Reducer</h2>
<h3 id="-state-">设计State的值</h3>
<p>React和Redux的核心原则之一是UI应该基于你的状态。</p>
<p>核心的是：todoList和当前的filter选项。todoItem包含name，completed status，id，color分类。Filter包含color和status。</p>
<p>todos是应用级别的state，然而filter选型是UI级别的state。</p>
<h3 id="-state-">设计state结构</h3>
<p>Redux中，我们的状态一般使用普通的JS对象和数组来构成。</p>
<h3 id="-actions">设计Actions</h3>
<p>描述当前发送了什么事件的action。</p>
<p>1、add，toggle，select color，delete，mark all completed，clear all。。。</p>
<h3 id="-reducers">写Reducers</h3>
<p>Redux App只有一个reducer函数，即root reducer。</p>
<p>Redux的目标之一是让你的代码可预测，当一个函数的输出只由输入参数决定，代码的工作方式和相关的测试会很容易。</p>
<h3 id="-reducers">分开Reducers</h3>
<p>Redux的reducers一般按照它们更新的state的部分来分开维护。</p>
<p>我们推荐基于功能来组织你的redux代码。同功能模块的redux代码经常分离到一个以slice结尾的文件中。</p>
<h3 id="-reducers">结合Reducers</h3>
<p>combineReducers方法。</p>
<h2 id="-store">第四部分，Store</h2>
<p>Store负责的部分：</p>
<p>1、将当前应用程序状态存储在内部。</p>
<p>2、允许使用store.getState来获取当前状态。</p>
<p>3、允许使用store.dispatch(action)来更新状态。</p>
<p>4、允许使用store.subscribe来注册回调函数。</p>
<p>5、允许使用store.subscribe返回的unsubscribe函数来注销回调。</p>
<h3 id="-store">创建Store</h3>
<p>主要使用createStore方法来创建Store。createStore的第二个参数可以接受preloadedState。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span> <span class="nx">createStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;redux&#39;</span><span class="p">;</span>
</pre></div>

</code></pre>
<h3 id="redux-store-">Redux Store的代码实现</h3>
<p>store有state和reducer的属性存储。getState返回当前的state。subscribe保存一个监听函数数组。dispatch调用reducer，然后保存状态，最后依次调用监听器。</p>
<p>store在初始化时dispatch了一个action，来初始化reducer提供的状态。</p>
<p>store的API包含{dispatch, subscribe, getState}。</p>
<h3 id="-store">配置Store</h3>
<p>Store允许使用插件来增强功能。插件可以提供自身版本的dispatch，getState和subscribe函数。</p>
<p>Redux里有一个compose方法来混合多个插件功能。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">composedEnhancer</span> <span class="o">=</span> <span class="nx">compose</span><span class="p">(</span><span class="nx">sayHiDispatch</span><span class="p">,</span> <span class="nx">includeMeaningOfLife</span><span class="p">);</span>
<span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">,</span> <span class="kc">undefined</span><span class="p">,</span> <span class="nx">composedEnhancer</span><span class="p">);</span>
</pre></div>

</code></pre>
<h3 id="-">中间件</h3>
<p>插件的功能非常强大，因为插件可以重写dispatch，getState和subscribe。但是大多数情况下，我们只需要自定义我们的dispatch的表现。</p>
<p>Redux允许使用一种特殊的插件来自定义dispatch，这种特殊的插件叫做middleware。</p>
<h3 id="-">使用中间件</h3>
<p>主要使用applyMiddleware方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span><span class="nx">createStore</span><span class="p">,</span> <span class="nx">applyMiddleware</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;redux&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">middlewareEnhancer</span> <span class="o">=</span> <span class="nx">applyMiddleware</span><span class="p">(</span><span class="nx">print1</span><span class="p">,</span> <span class="nx">print2</span><span class="p">,</span> <span class="nx">print3</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">,</span> <span class="nx">middlewareEnahancer</span><span class="p">)</span><span class="c1">//如果没有初始化状态，插件可以是第二个参数。</span>
</pre></div>

</code></pre>
<p>Middleware围绕store的dispatch方法形成了一个pipeline。跟recuder不同的是，middleware可以包含副作用。</p>
<h3 id="-">写自定义的中间件</h3>
<p>Redux的middleware一般包含一系列的三层嵌套函数。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">exampleMiddleware</span><span class="p">(</span><span class="nx">storeAPI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="kd">function</span> <span class="nx">wrapDispatch</span><span class="p">(</span><span class="nx">next</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kd">function</span> <span class="nx">handleAction</span><span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//可以使用storeAPI.dispatch(action)来重启流水线</span>
      <span class="c1">//可以使用storeAPI.getState来获取状态</span>
      <span class="c1">//可以使用next(action)来执行流水线的下一个方法</span>
      <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>只有handleAction的函数代码在action被dispatch时被调用。</p>
<h3 id="middleware-">Middleware的使用场景</h3>
<p>middleWare可以做很多事情。</p>
<p>1、打印一些日志。</p>
<p>2、设置定时器。</p>
<p>3、调用async的API。</p>
<p>4、修改action。</p>
<p>5、暂停action或stop action。</p>
<p>中间件旨在包含具有副作用的逻辑。此外，中间件可以让dispatch接受不是普通对象的action。</p>
<h3 id="redux-devtools">Redux DevTools</h3>
<p>在安装浏览器Redux-DevTools插件后，我们需要在store中配置一个配套的插件才可以使用浏览器插件。</p>
<p>我们需要安装一个redux-devtools-extension的npm包，该npm包导出comoseWidthDevTools方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span> <span class="nx">composeWithDevTools</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;redux-devtools-extension&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">composedEnhancer</span> <span class="o">=</span> <span class="nx">composeWithDevTools</span><span class="p">(</span><span class="nx">applyMiddleware</span><span class="p">(</span><span class="nx">print1</span><span class="p">,</span><span class="nx">print2</span><span class="p">));</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">,</span> <span class="nx">composedEnhancer</span><span class="p">);</span>
</pre></div>

</code></pre>
<h2 id="-ui-react">第五部分，UI和React</h2>
<p>React中的UI可以理解为state的函数，Redux包含状态并响应UI的交互动作。</p>
<h3 id="react-redux">React-redux</h3>
<p>官方的react的包为react-redux。</p>
<h3 id="-">设计组件树</h3>
<p>和设计state的结构类似，我们也需要根据需求来设计UI组件树。</p>
<h3 id="-useselector-">使用useSelector来读取状态</h3>
<p>useSelector接受一个选择函数。选择函数的输入参数为整个state，可以返回state的部分值，也可以返回计算的值。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">selectTodos</span> <span class="o">=</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">;</span>
<span class="c1">//</span>
<span class="kr">const</span> <span class="nx">selectTotalCompletedTodos</span> <span class="o">=</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">completedTodos</span> <span class="o">=</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">todo</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">completed</span><span class="p">);</span>
  <span class="k">return</span> <span class="nx">completedTodos</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>useSelector会订阅Redux Store的state改变事件。如果state改变，它会调用selector函数。如果selector函数的返回和上一次的值不同，useSelector会使我们的组件重新渲染。</p>
<p>注意：useSelector使用===来比较state是否改变。eg: map的数组每次都会触发重新渲染。</p>
<h3 id="-usedispatch">使用useDispatch</h3>
<p>react-redux的useDispatch的结果为store的dispatch方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">dispatch</span> <span class="o">=</span> <span class="nx">useDispatch</span><span class="p">();</span>
</pre></div>

</code></pre>
<h3 id="-provider-store">使用Provider来提供Store</h3>
<p>我们需要告诉React-redux，我们使用是全局store。这通过&lt;Provider&gt;组件包裹&lt;App&gt;组件，然后将store设置为&lt;Provider&gt;的store属性。</p>
<h3 id="react-redux-">React-Redux模式</h3>
<h4 id="-">全局状态、组件状态和表单</h4>
<p>只在一个地方用到的状态应该保存为组件状态，跨组件用到的状态可以放到redux中。</p>
<p>eg：header的input的值，其它组件不关心，放到redux没有任何好处，应该保留在组件内。</p>
<p>经验法则：</p>
<p>1、应用的其它部分关心这个数据吗？</p>
<p>2、是否需要根据原始数据来派生其它数据？</p>
<p>3、是否使用相同的数据来驱动多个组件？</p>
<p>4、将这个状态恢复到指定的时间，有价值吗？</p>
<p>5、你想缓存数据吗？</p>
<p>6、热加载UI组件时，是否需要保存这些数据？</p>
<p>大多数表单组件的状态不应该保存在Redux中，一般在编辑时保存在表单组件中，用户完成表单后dispatch到store中。</p>
<h4 id="-selectors">在组件中使用多个Selectors</h4>
<p>当组件中使用多个redux状态时，我们可以在组件中使用多个useSelector。这是个好主意，每一次的useSelector需要尽可能少得返回值。</p>
<h4 id="-id-data">通过ID来选择data</h4>
<p>&lt;TodoList&gt;读取整个state.todos数组，然后将数组的item传递给&lt;TodoListItem&gt;。</p>
<p>但是这有潜在的性能问题：</p>
<p>1、改变todo对象，意味着需要创建新的todo和新的state.todos数组。</p>
<p>2、每一次更新todo对象时，整个TodoList都会重新渲染。</p>
<p>3、由于React组件重渲染时，React会递归得渲染它的所有子组件，这意味着所有&lt;TodoListItem&gt;组件也会重新渲染。</p>
<p>重新渲染大量组件会导致应用变慢。</p>
<p>优化的方法：</p>
<p>1、使用React.momo来包裹住所有的TodoListItem组件，这样它们只会在它们的props真正改变的时候重新渲染。</p>
<p>2、另外一种方法是，&lt;TodoList&gt;组件只读取IDS，然后把ID传递给&lt;TodoListItem&gt;。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">selectTodoIds</span> <span class="o">=</span> <span class="nx">useSelector</span><span class="p">(</span><span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">todo</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="p">));</span>
</pre></div>

</code></pre>
<p>上述代码每次都返回了新数组，默认情况下会重新渲染组件。一个可行的方式是改变useSelector的比较逻辑。useSelector可以在第二个参数中传入比较函数。</p>
<p>比较函数接受newState和oldState，如果相同，则返回true，如果不相同，则返回false。React-Redux有一个shallowEqual组件来比较数组的元素是否相同。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span> <span class="nx">shallowEqual</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;react-redux&#39;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">todoIds</span> <span class="o">=</span> <span class="nx">useSelector</span><span class="p">(</span><span class="nx">state</span><span class="o">=&gt;</span><span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">todo</span><span class="o">=&gt;</span><span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="p">),</span> <span class="nx">shallowEqual</span><span class="p">);</span>
</pre></div>

</code></pre>
<h2 id="-">第六部分，异步逻辑和数据获取</h2>
<h3 id="redux-">Redux中间件和副作用</h3>
<p>Redux不知道异步逻辑。所有的异步逻辑需要在store之外完成。</p>
<p>Redux middleware是用来包含逻辑和副作用代码的。</p>
<h3 id="-middleware-">写一个异步Middleware方法</h3>
<p>如果写一个middleware，可以dispatch一个function，而不是一个object，那么我们就可以将逻辑分离出去。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">asyncFunctionMiddleware</span> <span class="o">=</span> <span class="nx">storeAPI</span> <span class="o">=&gt;</span> <span class="nx">next</span> <span class="o">=&gt;</span> <span class="nx">action</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span><span class="p">(</span><span class="k">typeof</span> <span class="nx">action</span> <span class="o">===</span> <span class="s1">&#39;function&#39;</span><span class="p">){</span>
    <span class="k">return</span> <span class="nx">action</span><span class="p">(</span><span class="nx">storeAPI</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">,</span> <span class="nx">storeAPI</span><span class="p">.</span><span class="nx">getState</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nx">next</span><span class="p">(</span><span class="nx">action</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">//</span>
<span class="kd">function</span> <span class="nx">fetchSomeData</span><span class="p">(</span><span class="nx">dispatch</span><span class="p">,</span> <span class="nx">getState</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">client</span><span class="p">.</span><span class="nx">get</span><span class="p">(</span><span class="s1">&#39;todos&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">todos</span> <span class="o">=&gt;</span> <span class="p">{</span>
     <span class="nx">dispatch</span><span class="p">({</span><span class="nx">type</span><span class="o">:</span><span class="s1">&#39;todos/todosLoaded&#39;</span><span class="p">,</span><span class="nx">payload</span><span class="o">:</span> <span class="nx">todos</span><span class="p">});</span>
  <span class="p">});</span>
<span class="p">}</span>
<span class="c1">//</span>
<span class="nx">dispatch</span><span class="p">(</span><span class="nx">fetchSomeData</span><span class="p">);</span>
</pre></div>

</code></pre>
<h3 id="redux-">Redux异步数据流</h3>
<p>主要是middleware处理了其它类型的action，然后调用了异步方法，当异步方法完成时，再dispatch一个普通的object。</p>
<h3 id="-redux-thunk-">使用Redux Thunk中间件</h3>
<p>Redux有一个官方的异步中间件，redux-thunk。这个中间件会传递dispatch和getState给dispatch的函数。单词thunk是一个编程术语，意思是一段做延迟工作的代码。</p>
<h3 id="config-store">config Store</h3>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i redux-thunk
</pre></div>

</code></pre>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">thunkMiddleware</span> <span class="nx">from</span> <span class="s1">&#39;redux-thunk&#39;</span><span class="p">;</span>
<span class="kr">const</span> <span class="nx">comosedEnhancer</span> <span class="o">=</span> <span class="nx">applyMiddleware</span><span class="p">(</span><span class="nx">thunkMiddleware</span><span class="p">);</span>
<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">createStore</span><span class="p">(</span><span class="nx">rootReducer</span><span class="p">,</span> <span class="nx">composedEnhancer</span><span class="p">);</span>
</pre></div>

</code></pre>
<h3 id="-todoitems">保存todoItems</h3>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">export</span> <span class="kd">function</span> <span class="nx">saveNewTodo</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">async</span> <span class="kd">function</span> <span class="nx">saveNewTodoThunk</span><span class="p">(</span><span class="nx">dispatch</span><span class="p">,</span><span class="nx">getState</span><span class="p">)</span> <span class="p">{</span>
     <span class="kr">const</span> <span class="nx">initTodo</span> <span class="o">=</span> <span class="p">{</span><span class="nx">text</span><span class="p">};</span>
     <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">client</span><span class="p">.</span><span class="nx">post</span><span class="p">(</span><span class="s1">&#39;/fakeApi/todos&#39;</span><span class="p">,</span> <span class="p">{</span><span class="nx">todo</span><span class="o">:</span> <span class="nx">initTodo</span><span class="p">});</span>
     <span class="nx">dispatch</span><span class="p">({</span><span class="nx">type</span><span class="o">:</span><span class="s1">&#39;todos/todoAdded&#39;</span><span class="p">,</span> <span class="nx">payload</span><span class="o">:</span> <span class="nx">response</span><span class="p">.</span><span class="nx">todo</span> <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>这种写函数来准备dispatch内容的方式叫做 action creator模式。</p>
<p>Thunk函数既可用于异步逻辑，也可用于同步逻辑。thunk提供了一种方法来编写任何需要访问dispatch和getState的可重用逻辑。</p>
<h2 id="-redux-">第七部分，标准Redux模式</h2>
<h3 id="action-">Action生成器</h3>
<p>一个Action生成器是一个创建Action对象的函数。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">todoAdded</span> <span class="o">=</span> <span class="nx">text</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">{</span>
    <span class="nx">type</span><span class="o">:</span> <span class="s1">&#39;todos/todoAdded&#39;</span><span class="p">,</span>
    <span class="nx">payload</span><span class="o">:</span> <span class="nx">text</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">//</span>
<span class="nx">store</span><span class="p">.</span><span class="nx">dispatch</span><span class="p">(</span><span class="nx">todoAdded</span><span class="p">(</span><span class="err">`</span><span class="nx">Buy</span> <span class="nx">milk</span><span class="err">`</span><span class="p">));</span>
</pre></div>

</code></pre>
<p>直接传递给dispatch，action生成器的结果即可。</p>
<p>最终两个作用：</p>
<p>1、准备和格式化action对象。</p>
<p>2、封装了创建action需要的额外工作。</p>
<h3 id="-selectors">缓存Selectors</h3>
<p>某些情况下，我们需要根据state计算出来的派生数据。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">selectTodoIds</span> <span class="o">=</span> <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">todo</span> <span class="o">=&gt;</span> <span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
</pre></div>

</code></pre>
<p>除了自定义比较函数外，还可以使用memoized selectors。memoized selector可以缓存最近的值，如果输入参数相同，直接返回缓存的结果。</p>
<h3 id="-createselector">使用createSelector</h3>
<p>Reselect库提供了一个createSelector来返回momoized selector函数。</p>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i reselect
</pre></div>

</code></pre>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span> <span class="nx">createSelector</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;reselect&#39;</span><span class="p">;</span>
<span class="kr">export</span> <span class="kr">const</span> <span class="nx">selectTodoIds</span> <span class="o">=</span> <span class="nx">createSelector</span><span class="p">(</span>
  <span class="nx">state</span> <span class="o">=&gt;</span> <span class="nx">state</span><span class="p">.</span><span class="nx">todos</span><span class="p">,</span>
  <span class="nx">todos</span> <span class="o">=&gt;</span> <span class="nx">todos</span><span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">todo</span><span class="o">=&gt;</span><span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="p">)</span>
<span class="p">)</span>
<span class="c1">//</span>
<span class="kr">const</span> <span class="nx">todoIds</span> <span class="o">=</span> <span class="nx">useSelector</span><span class="p">(</span><span class="nx">selectTodoIds</span><span class="p">)</span>
</pre></div>

</code></pre>
<p>Memoized selectors只在你通过原始state计算派生数据时有用。如果只是返回原始数据，直接返回即可。</p>
<p>循环依赖问题：如果两个切片文件互相依赖，可能导致应用崩溃。如果那样的话，尝试把公共代码移到另一个文件。</p>
<h3 id="-">异步请求状态</h3>
<p>异步请求时间可能会比较长，需要增加loading提示。</p>
<p>Redux经常这样处理：</p>
<p>1、添加loading state的值来表示当前请求状态。</p>
<p>2、在API调用前，dispatch一个request satrted action，这个action改变请求状态到loading。</p>
<p>3、在API返回后，dispatch一个request end action，改变请求状态到done。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">{</span>
  <span class="nx">status</span><span class="o">:</span> <span class="s1">&#39;idle&#39;</span> <span class="c1">// loading, succeeded, failed</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>字符串表示的状态值更具拓展性，建议使用字符串枚举值。</p>
<h3 id="flux-action-">Flux标准Action规范</h3>
<p>这是一种建议的方法，用来规范action对象的字段。</p>
<p>1、如果你的action对象有具体的数据，数据应该在action.payload中。</p>
<p>2、action可以有action.meta字段添加额外的描述性数据。</p>
<p>3、action可以有action.error字段添加错误信息。</p>
<p>如果有错误，error需要设置为true，同时payload为error对象。</p>
<p>然而大多数应用都不会使用action.error的值，而是使用两个不同的type来标记成功和失败。eg：todos/todosLoadingSucceed，todos/todosLoadingFailed。</p>
<h3 id="-">规一化状态</h3>
<p>在大型Redux应用中，使用归一化的结构存储数据很常见。</p>
<p>归一化的结构存储意味着：</p>
<p>1、数据块只有一个拷贝。</p>
<p>2、允许直接使用Id来查找Item。</p>
<p>3、根据Id来引用其它项，而不是复制整个项。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">rootState</span> <span class="o">=</span> <span class="p">{</span>
  <span class="nx">todos</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">status</span><span class="o">:</span> <span class="s1">&#39;idle&#39;</span><span class="p">,</span>
    <span class="nx">entities</span><span class="o">:</span> <span class="p">{</span>
      <span class="mi">2</span><span class="o">:</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span><span class="mi">2</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s1">&#39;Buy milk&#39;</span><span class="p">,</span> <span class="nx">completed</span><span class="o">:</span> <span class="kc">false</span> <span class="p">},</span>
      <span class="mi">7</span><span class="o">:</span> <span class="p">{</span> <span class="nx">id</span><span class="o">:</span><span class="mi">7</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span><span class="s1">&#39;Clean room&#39;</span><span class="p">,</span><span class="nx">completed</span><span class="o">:</span> <span class="kc">true</span> <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<h3 id="thunks-promises">Thunks和Promises</h3>
<p>我们可以写返回promise的thunk函数，然后在组件中等待promise结果。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="nx">await</span> <span class="nx">dispatch</span><span class="p">(</span><span class="nx">saveNewTodo</span><span class="p">(</span><span class="nx">trimmedText</span><span class="p">));</span>
<span class="nx">setText</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">);</span>
<span class="nx">setStatus</span><span class="p">(</span><span class="s1">&#39;idle&#39;</span><span class="p">)</span>
</pre></div>

</code></pre>
<h2 id="-redux-toolkit">第八部分，Redux Toolkit</h2>
<p>Redux的许多方面都涉及到编写一些冗长的代码，设置Redux Store的步骤较繁琐，最后，很多时候用户不确定编写Redux逻辑的正确方法是什么。</p>
<p>这就是Redux团队创建Redux Toolkit的原因。Redux Toolkit包含我们认为构建Redux应用程序必不可少的方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="nx">npm</span> <span class="nx">i</span> <span class="err">@</span><span class="nx">reduxjs</span><span class="o">/</span><span class="nx">toolkit</span>
</pre></div>

</code></pre>
<h3 id="configurestore">ConfigureStore</h3>
<p>Redux Toolkit有一个ConfigureStore来简化Store的设置过程。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="p">{</span> <span class="nx">configureStore</span> <span class="p">}</span> <span class="nx">from</span> <span class="s1">&#39;@reduxjs/toolkit&#39;</span><span class="p">;</span>

<span class="kr">const</span> <span class="nx">store</span> <span class="o">=</span> <span class="nx">configureStore</span><span class="p">({</span>
  <span class="nx">reducer</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">//...</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">store</span><span class="p">;</span>
</pre></div>

</code></pre>
<p>configureStore做的工作：</p>
<p>1、将reducer切片结合为root reducer函数，并创建store。</p>
<p>2、添加了thunk中间件，添加了其它检查错误的中间件，自动设置了Redux DevTools插件。</p>
<h3 id="-">包清理</h3>
<p>Redux Toolkit引用了Redux，redux-thunk和reselect，并重新导出了这些APIS，这样我们可以更少的引用包。</p>
<h3 id="-">写切片</h3>
<p>Redux Toolkit有一个createSlice的API来简化slice的创建。</p>
<p>作用：</p>
<p>1、我们可以以对象的形式书写reducers，而不是使用switch/case语句。</p>
<p>2、将能够编写更短的不可变更的更新。允许我们安全的直接变异状态。</p>
<p>3、所有的Action creators会根据reducer函数自动生成。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">const</span> <span class="nx">todosSlice</span> <span class="o">=</span> <span class="nx">createSlice</span><span class="p">({</span>
  <span class="nx">name</span><span class="o">:</span> <span class="s1">&#39;todos&#39;</span><span class="p">,</span>
  <span class="nx">initialState</span><span class="p">,</span>
  <span class="nx">reducers</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">todoAdded</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">entities</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="kr">export</span> <span class="kr">const</span> <span class="p">{</span> <span class="nx">todoAdded</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">todosSlice</span><span class="p">.</span><span class="nx">actions</span><span class="p">;</span>

<span class="kr">export</span> <span class="k">default</span> <span class="nx">todosSlice</span><span class="p">.</span><span class="nx">reducer</span><span class="p">;</span>
</pre></div>

</code></pre>
<p>name参数：action type的名字前缀。</p>
<p>initialState：reducer的初始化状态。</p>
<p>reducers：key为string，value是case reducer函数。</p>
<p>Action Creator：createSlice自动生成action type(name/keyName)，默认接受一个参数，然后把参数设置到action.payload。</p>
<p>在Redux Toolkit的createSlice和createReducer函数内部，由于它们使用了Immer库，你可以直接修改状态的值。</p>
<pre><code class="lang-js"><div class="highlight"><pre>  <span class="c1">// createSlice的reducers的key可以是一个对象，然后包含多个参数</span>
  <span class="nx">todoColorSelcted</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">reducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="p">{</span> <span class="nx">color</span><span class="p">,</span> <span class="nx">id</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">;</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">entities</span><span class="p">[</span><span class="nx">id</span><span class="p">].</span><span class="nx">color</span> <span class="o">=</span> <span class="nx">color</span><span class="p">;</span>
    <span class="p">},</span>
    <span class="c1">//@ts-ignore</span>
    <span class="nx">prepare</span><span class="p">(</span><span class="nx">id</span><span class="o">:</span> <span class="nx">string</span><span class="p">,</span> <span class="nx">color</span><span class="o">:</span> <span class="nx">string</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="p">{</span>
        <span class="nx">payload</span><span class="o">:</span> <span class="p">{</span> <span class="nx">id</span><span class="p">,</span> <span class="nx">color</span> <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div>

</code></pre>
<h3 id="-thunk">写Thunk</h3>
<p>Redux Toolkit有一个createAsyncThunk API来简化Thunk的声明。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">export</span> <span class="kr">const</span> <span class="nx">fetchTodos</span> <span class="o">=</span> <span class="nx">createAsyncThunk</span><span class="p">(</span><span class="s1">&#39;todos/fetchTodos&#39;</span><span class="p">,</span> <span class="nx">async</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">response</span> <span class="o">=</span> <span class="nx">await</span> <span class="nx">fetch</span><span class="p">(</span><span class="s1">&#39;./todos.json&#39;</span><span class="p">).</span><span class="nx">then</span><span class="p">(</span><span class="nx">res</span> <span class="o">=&gt;</span> <span class="nx">res</span><span class="p">.</span><span class="nx">json</span><span class="p">());</span>
  <span class="k">return</span> <span class="nx">response</span><span class="p">.</span><span class="nx">todos</span><span class="p">;</span>
<span class="p">});</span>
<span class="c1">//</span>
<span class="p">{</span> <span class="c1">// ...</span>
  <span class="nx">extraReducers</span><span class="o">:</span> <span class="nx">builder</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">builder</span><span class="p">.</span><span class="nx">addCase</span><span class="p">(</span><span class="nx">fetchTodos</span><span class="p">.</span><span class="nx">pending</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s1">&#39;loading&#39;</span>
    <span class="p">}).</span><span class="nx">addCase</span><span class="p">(</span><span class="nx">fetchTodos</span><span class="p">.</span><span class="nx">fulfilled</span><span class="p">,</span> <span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
      <span class="kr">const</span> <span class="nx">newEntities</span><span class="o">:</span> <span class="p">{</span> <span class="p">[</span><span class="nx">key</span><span class="o">:</span> <span class="nx">string</span><span class="p">]</span><span class="o">:</span> <span class="nx">ITodoItem</span> <span class="p">}</span> <span class="o">=</span> <span class="p">{};</span>
      <span class="nx">action</span><span class="p">.</span><span class="nx">payload</span><span class="p">.</span><span class="nx">forEach</span><span class="p">((</span><span class="nx">todo</span><span class="o">:</span> <span class="nx">ITodoItem</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
        <span class="nx">newEntities</span><span class="p">[</span><span class="nx">todo</span><span class="p">.</span><span class="nx">id</span><span class="p">]</span> <span class="o">=</span> <span class="nx">todo</span><span class="p">;</span>
      <span class="p">})</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">entities</span> <span class="o">=</span> <span class="nx">newEntities</span><span class="p">;</span>
      <span class="nx">state</span><span class="p">.</span><span class="nx">status</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">;</span>
    <span class="p">})</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>createAsyncThunk会生成三个action type：fetchTodos.pending=todos/fetchTodos/pending...。</p>
<p>createSlice接受一个extraReducers的参数选项，可以使用builder.addCase(actionCretaor,caseReducer)来添加action。</p>
<h3 id="-state">规范化state</h3>
<h2 id="-">参考文档</h2>
<p><a href="https://redux.js.org/tutorials/fundamentals/part-1-overview">https://redux.js.org/tutorials/fundamentals/part-1-overview</a></p>
<p><a href="https://daveceddia.com/react-redux-immutability-guide/">https://daveceddia.com/react-redux-immutability-guide/</a></p>
<p><a href="https://daveceddia.com/why-not-modify-react-state-directly/">https://daveceddia.com/why-not-modify-react-state-directly/</a></p>
</body>
</html>
