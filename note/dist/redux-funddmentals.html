<!DOCTYPE html>
<html>
<head>
  <title>Redux基本原理</title>
  <link rel="stylesheet" href="/note/note.css?ts=1643986647513">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="redux-">Redux基本原理</h1>
<h2 id="-redux-">第一部分：Redux概述</h2>
<p>What：Redux是一个使用叫actions的事件来管理和更新应用状态的类库。它作为整个应用程序状态的集中式存储，其规则确保状态只能以可预测的方式更新。</p>
<p>Why：Redux提供的模式和工具使您更容易理解应用程序中的状态更新的时间、地点、原因和方式，以及发生这些更改时应用程序需要做的逻辑处理。</p>
<p>When：Redux也有利弊，需要学习新概念，书写更多的代码，添加一些间接方法，并要求你遵循某些限制。是短期生产力和长期生产力之间的权衡。</p>
<p>在下列场景下更有用：</p>
<p>1、有大量的应用程序状态需要在应用程序的大量地方。</p>
<p>2、应用程序状态会高频更新。</p>
<p>3、更新状态的逻辑很复杂。</p>
<p>4、多人开发，中大型代码库。</p>
<h3 id="redux-">Redux类库和工具</h3>
<p>Redux是一个独立的JS类库，通常它会和其它类库配合使用。React-redux是官方库。Redux-Toolkit是我们推荐的编写Redux逻辑需要使用的类库，包含了很多有用的函数。React-DevTools-Extension展示了状态的变更历史。</p>
<h3 id="redux-">Redux基本概念</h3>
<h4 id="redux-store">Redux Store</h4>
<p>Store包含了应用的全局状态。</p>
<p>Store的特点：</p>
<p>1、不可直接修改Store中的状态。</p>
<p>2、导致状态更新的唯一方法是创建一个普通的Action对象，该对象描述应用程序中发生的事情。然后将该Action Dispatch到Store中。</p>
<p>3、在Dispatch时，Store会运行root reducer函数，并让它根据old state和Action来计算new state。</p>
<p>4、最后，Store通知订阅者状态已经更新，因此UI可以用新数据更新。</p>
<p>UI的作用：在应用中，UI应该在屏幕上展示应用状态。</p>
<h4 id="data-flow">Data Flow</h4>
<p>1、Action做为UI的响应被Dispatch出来。</p>
<p>2、Store执行Reducer函数来计算新状态，然后通知订阅者。</p>
<p>3、UI渲染收到状态变更通知展示新状态。</p>
<h2 id="-">第二部分：概念和数据流转</h2>
<h3 id="-">背景概念</h3>
<h4 id="-">状态管理</h4>
<p>React管理counter的简单组件形式：自包含应用，包含了state，view和actions。</p>
<p>单向数据流：</p>
<p>1、状态描述应用在特定时间点的状态；</p>
<p>2、UI渲染基于state。</p>
<p>3、当一些事件发生，state根据发生了什么开始更新。</p>
<p>4、UI根据new state来重新渲染。</p>
<p>当多个组件需要共享和使用相同的状态时，简单性就会崩溃。有时，可以通过提升状态到父组件来解决，但这并不总是有帮助的。</p>
<p>通过定义和分离状态管理中涉及到的概念，并强制实施在视图和状态之间保持独立性的规则，我们为代码提供了更多的结构和可维护性。</p>
<h4 id="-">不可变性</h4>
<p>JS的对象和数组都是不可变的，为了更新数据，需要拷贝已存在的对象和数组，然后更改拷贝后的数据。</p>
<p>我们可以使用对象和数组的展开运算符，或某些方法来返回拷贝对象。</p>
<p>Redux期望所有的更新都是不可变更新。</p>
<p>这意味着你需要不断地创造新值并替换旧值，而不是使用传统的变量。</p>
<p>GiveAwesomePowers(person)：对象的内部结构发生了变化，但对象引用没有发生变化。</p>
<p>纯函数概念：1、一个纯函数有相同的输入时，必须有相同的输出；2、一个纯函数不能有副作用。</p>
<p>副作用概念：1、修改函数输入参数；2、修改函数外的其它状态，eg：全局变量；3、调用API；4、console.log；5、Math.random。</p>
<p>JS数组的变异方法：push，pop，shift，unshift，sort，reverse，splice。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">//copy的方法</span>
<span class="kd">let</span>  <span class="nx">a</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]</span>
<span class="kd">let</span> <span class="nx">copy1</span> <span class="o">=</span> <span class="p">[...</span><span class="nx">a</span><span class="p">];</span>
<span class="kd">let</span> <span class="nx">copy2</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">slice</span><span class="p">();</span>
<span class="kd">let</span> <span class="nx">copy3</span> <span class="o">=</span> <span class="nx">a</span><span class="p">.</span><span class="nx">concat</span><span class="p">();</span>
</pre></div>

</code></pre>
<p>giveAwesomePowers的纯函数版本，先拷贝person，然后再添加新属性。</p>
<p>React更喜欢不变性：在React中，不要直接改变state和props。</p>
<p>React中：直接改变state可能导致奇怪的bug，同时使组件难以优化。</p>
<p>提高组件性能的通用手法是使组件变纯，组件的重新渲染只是当它的props改变，而不是每次父组件重新渲染时。</p>
<p>不可变性对纯函数很重要：默认情况下，React组件在父组件重渲染时，或使用setState时会重新渲染。</p>
<p>继承了React.PureComponent的组件只在它的props改变或setState时，重新渲染，是常见的性能优化手段。</p>
<p>JS的对象和数组直接使用===，判断的是引用相等。</p>
<p>为什么不遍历检查相等？根据对象的大小，遍历检查的时间差异很大。而引用相等判断会在常量时间内完成。</p>
<p>React的setState方法会浅拷贝state，然后和参数合并来生成新的state。</p>
<h5 id="-">常见场景</h5>
<p>改变对象：利用展开运算符，多层对象需要多层展开。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">{</span>
  <span class="p">...</span><span class="nx">state</span><span class="p">,</span>
  <span class="nx">prop</span><span class="o">:</span> <span class="nx">state</span><span class="p">.</span><span class="nx">age</span><span class="o">++</span><span class="p">,</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>插入数组：利用展开运算符。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="p">[</span>
  <span class="nx">newItem</span><span class="p">,</span>
  <span class="p">...</span><span class="nx">state</span>
<span class="p">]</span>
</pre></div>

</code></pre>
<p>数组中item变更：map方法返回新数组即可。</p>
<p>数组中插入item：先slice拷贝，然后splice。</p>
<p>数组中删除item：使用filter即可。</p>
<h5 id="-immer-">使用Immer类库更新</h5>
<p>Immer让你可以以常见的手法来更新状态。Immer会帮你处理为不可变更新。</p>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i immer 
</pre></div>

</code></pre>
<p>然后引入produce方法。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kd">function</span> <span class="nx">immerifiedReducer</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">action</span><span class="p">)</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">key</span> <span class="o">=</span> <span class="s1">&#39;ravenclaw&#39;</span><span class="p">;</span>

  <span class="k">return</span> <span class="nx">produce</span><span class="p">(</span><span class="nx">state</span><span class="p">,</span> <span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">draft</span><span class="p">.</span><span class="nx">houses</span><span class="p">[</span><span class="nx">key</span><span class="p">].</span><span class="nx">points</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
  <span class="p">});</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<p>produce方法返回了一个柯里化的方法，所以setState的函数版本可以直接传递一个参数。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">(</span><span class="nx">produce</span><span class="p">(</span><span class="nx">draft</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">draft</span><span class="p">.</span><span class="nx">count</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}));</span>
</pre></div>

</code></pre>
<p>Immer：数据中未更改的部分不需要复制，而是在内存中与相同状态的旧版本共存。使用Immer时，会对草稿对象进行更改，该对象会记录更改并负责创建必要的副本。</p>
<h5 id="immer-">Immer的原理</h5>
<p>草稿是当前状态的代理，Immer会将你对草稿的操作记录下来，一旦你的更新方法运行结束，Immer会根据操作记录和nextState来生成nextState。</p>
<h2 id="-">参考文档</h2>
<p><a href="https://redux.js.org/tutorials/fundamentals/part-1-overview">https://redux.js.org/tutorials/fundamentals/part-1-overview</a></p>
<p><a href="https://daveceddia.com/react-redux-immutability-guide/">https://daveceddia.com/react-redux-immutability-guide/</a></p>
<p><a href="https://daveceddia.com/why-not-modify-react-state-directly/">https://daveceddia.com/why-not-modify-react-state-directly/</a></p>
</body>
</html>
