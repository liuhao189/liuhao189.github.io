<!DOCTYPE html>
<html>
<head>
  <title>Gatsby本地开发 & 路由和页面</title>
  <link rel="stylesheet" href="/note/note.css?ts=1648480550828">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="gatsby-">Gatsby本地开发 &amp; 路由和页面</h1>
<h2 id="-">环境变量</h2>
<p>所有的项目和OS环境变量只在构建时可用或Node.js运行时。它们不应该在客户端代码运行时可用，客户端代码在构建时会被环境变量的值替换。这通过Webpack的DefinePlugin实现。</p>
<p>一旦环境变量嵌入到客户端代码中，它们就可以通过process.env全局变量来访问。</p>
<p>注意：因为环境变量在构建时被嵌入，当你改变它们的时候，你需要重启和重构建你的网站。</p>
<h3 id="-">定义客户端环境变量</h3>
<p>你可以在根目录定义.env.development或.env.production文件。</p>
<p>除了在.env.*中的环境变量，你还可以定义OS Env变量，OS Env变量中以GATSBY_开头的可以在客户端浏览器代码中访问。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">//gatsby-config.js</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">SECRET</span> <span class="o">=</span> <span class="s1">&#39;my_secret&#39;</span><span class="p">;</span>
<span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">GATSBY_DISK_API</span> <span class="o">=</span> <span class="s1">&#39;disk_api&#39;</span><span class="p">;</span>
<span class="c1">// 浏览器中仅GATSBY_DISK_API可访问</span>
</pre></div>

</code></pre>
<h3 id="node-js-">Node.js环境变量</h3>
<p>Gatsby在构建时运行若干个Node.js的脚本，明显的是gatsby-config.js和gatsby-node.js脚本。你可以按照常用的方式来添加环境变量。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="nx">MY_ENV_VAR</span><span class="o">=</span><span class="nx">foo</span> <span class="nx">npm</span> <span class="nx">run</span> <span class="nx">develop</span>
</pre></div>

</code></pre>
<p>在node中使用这些变量.env.*中的环境变量，需要下面的代码：</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">// gatsby-config.js</span>
<span class="nx">require</span><span class="p">(</span><span class="err">&#39;</span><span class="nx">dotenv</span><span class="p">).</span><span class="nx">config</span><span class="p">({</span>
    <span class="nx">path</span><span class="o">:</span> <span class="err">`</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">$</span><span class="p">{</span><span class="nx">process</span><span class="p">.</span><span class="nx">env</span><span class="p">.</span><span class="nx">NODE_ENV</span><span class="p">}</span><span class="err">`</span>
<span class="p">})</span>
</pre></div>

</code></pre>
<h3 id="-">保留的环境变量</h3>
<p>NODE_ENV，PUBLIC_DIR。因为其它工具会用到。</p>
<p>ENABLE_GATSBY_REFRESH_ENDPOINT。</p>
<h3 id="-">构建时变量</h3>
<p>Gatsby在构建步骤中使用额外的环境变量来调整构建结果。eg：添加CI=true的环境变量，Gatsby会根据环境定制终端输出(比如去掉终端的进度条)。</p>
<p>Gatsby根据物理CPU数量，来调整最佳并行级别，在VM中，可以使用GATSBY_CPU_COUNT的环境变量来设置并行度。</p>
<h2 id="-">路由和页面</h2>
<p>因为许多工作已经在构建时完成，所以Gatsby的网站速度很快。</p>
<h3 id="-">创建页面</h3>
<p>路由可以通过三种方式创建：</p>
<p>1、在src/pages中添加React组件（注意：必须export default组件）。</p>
<p>2、使用File System Route API和GraphQL来创建页面。</p>
<p>3、在gatsby-node.js中使用createPages方法（插件也可以实现createPages来创建页面）。</p>
<h3 id="-src-pages-routes">在src/pages中定义routes</h3>
<p>每一个在src/pages里的js文件都会生成网页，这些页面的路径跟文件路径一致。</p>
<p>如果文件以index.js命名，文件名称会被命名为上级文件夹名称。</p>
<h3 id="-file-system-route-api">使用File System Route API</h3>
<p>你还可以基于nodes的列表创建多个页面。</p>
<pre><code class="lang-bash"><div class="highlight"><pre><span class="c"># src/pages/products/{Product.name}.js </span>
</pre></div>

</code></pre>
<h3 id="-gatsby-node-js">使用gatsby-node.js</h3>
<p>如果需要更多的控制，eg：通过pageContext传递数据或修改path，你可以使用Gatsby Node APIs。</p>
<p>具体可以参见markdown文件生成页面的例子。</p>
<h3 id="-">路由冲突</h3>
<p>当生成的页面path一致时，Gatsby会在构建时生成一个警告，但是编译依然会成功。后面的页面会覆盖前面的页面。</p>
<h3 id="-">嵌套路由</h3>
<p>可以在src/pages中添加文件夹目录结构来反映多级的URL。</p>
<h3 id="-link-">页面间通过Link跳转</h3>
<p>为了在页面之间跳转，你可以使用gatsby-link。使用gatsby-link可以给你性能优势（预加载和前端路由）。</p>
<p>另外，也可以通过a标签来跳转，这会重新刷新整个页面。</p>
<p>Gatsby在大多数情况下会记录滚动的位置。</p>
<h3 id="-">性能和预取资源</h3>
<p>为了提高性能，Gatsby会在当前页面预取link对应的资源。经过测试，Gatsby在鼠标hover到Link时，就开始预取。</p>
<h2 id="-">通用布局组件</h2>
<p>你可以学到如何创建和使用布局组件，怎样避免布局组件卸载和重渲染。</p>
<p>通用布局组件是什么？通用布局组件是跨多个页面共享的组件。</p>
<p>推荐在src/components里创建布局组件。</p>
<p>然后按常规组件引入布局组件使用即可。</p>
<h3 id="-">怎么防止布局组件重新渲染</h3>
<p>Gatsby默认情况不控制，当顶级组件在页面间变化时，React会整个重现渲染。这意味着共享的组件会unmout和remount。这会破坏CSS过度效果和清空组件内部的React状态。</p>
<p>你可以设置一个在页面间包裹的组件，这个组件在页面跳转时，不会被unmounted。主要通过Browser API的wrapPageElement来实现。</p>
<p>另外你也可以使用gataby-plugin-layout来避免布局组件unmounted，这个插件替你实现了wrapPageElement API。</p>
<h3 id="wrappageelement">WrapPageElement</h3>
<p>主要是在gatsby-browser.js里增加wrapPageElement的导出。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">export</span> <span class="kr">const</span> <span class="nx">wrapPageElement</span> <span class="o">=</span> <span class="p">(</span><span class="nx">apiContext</span><span class="p">,</span> <span class="nx">pluginOptions</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;apiContext&#39;</span><span class="p">,</span> <span class="nx">apiContext</span><span class="p">);</span>
  <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="s1">&#39;pluginOptions&#39;</span><span class="p">,</span> <span class="nx">pluginOptions</span><span class="p">);</span>
  <span class="k">return</span> <span class="p">(</span><span class="o">&lt;</span><span class="nx">WrapElement</span> <span class="p">{...</span><span class="nx">apiContext</span><span class="p">.</span><span class="nx">props</span><span class="p">}</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">apiContext</span><span class="p">.</span><span class="nx">element</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/WrapElement&gt;);</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<h1 id="-">样式</h1>
<p>有很多种方式向你的网站添加样式，可以通过Global CSS，Modular Stylesheets，CSS-in-JS，这些Gatsby都支持。</p>
<h3 id="-css">共享组件中添加CSS</h3>
<p>共享布局组件主要是在页面间共享的组件，包括样式，头组件和其它公共组件。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="c1">//src/components/layout.js</span>
<span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span>
<span class="kr">import</span> <span class="s2">&quot;./layout.css&quot;</span><span class="p">;</span> <span class="c1">//全局样式文件</span>
<span class="kr">export</span> <span class="k">default</span> <span class="kd">function</span> <span class="nx">Layout</span><span class="p">({</span> <span class="nx">children</span> <span class="p">})</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">&lt;</span><span class="nx">div</span><span class="o">&gt;</span><span class="p">{</span><span class="nx">children</span><span class="p">}</span><span class="o">&lt;</span><span class="err">/div&gt;</span>
<span class="p">}</span>
</pre></div>

</code></pre>
<h3 id="-gatsby-browser-js-css">在gatsby-browser.js中添加全局CSS</h3>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="s2">&quot;./src/styles/global.css&quot;</span>
</pre></div>

</code></pre>
<h3 id="-css">在组件中引入CSS</h3>
<p>直接引用即可。</p>
<h3 id="css-">CSS的缺陷</h3>
<p>主要是名字冲突和无意识的继承CSS属性的问题，BEM等可以部分解决这个问题，但是CSS Modules和CSS-in-JS是更好的方案。</p>
<h2 id="css-modules">CSS Modules</h2>
<p>组件作用域的CSS可以允许你在没有副作用的情况下书写传统CSS，不用担心选择器冲突或影响其它组件。</p>
<p>Gatsby默认就支持CSS Modules。</p>
<h3 id="-css-modules">什么是CSS Modules</h3>
<p>CSS模块非常流行，因为它可以生成独一无二的class和animation名字，同时可以让你在JS对象中访问这些名字。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="o">*</span> <span class="nx">as</span>  <span class="nx">ContainerStyles</span> <span class="nx">from</span> <span class="s1">&#39;./styles/wrap-page.module.css&#39;</span><span class="p">;</span>
</pre></div>

</code></pre>
<h3 id="-css-modules">什么时候使用CSS Modules</h3>
<p>CSS Module强烈推荐使用。因为这可以让你编写常规的，可复用的CSS文件，同时只打包需要的CSS可以获得性能提升。</p>
<h2 id="css-in-js-">CSS-in-JS来增强样式</h2>
<p>CSS-in-JS指的是通过JS来书写样式，而不是通过额外的CSS文件。这样可以很方便做到组件作用域，避免未使用的样式代码，更好的性能（没有CSS选择器），更好地动态修改样式。</p>
<p>组件层面：你必须使用组件来添加样式，契合了React的所有都是组件的理念。</p>
<p>作用域：组件内作用域。</p>
<p>动态：样式可以更方便得跟随组件状态变化。</p>
<p>类库：许多CSS-in-JS的类库会生成独一无二的className，自动添加浏览器厂商的前缀，懒加载CSS等功能。</p>
<p>gatsby默认不支持CSS-in-JS，需要引入第三方库。</p>
<h2 id="-sass">使用Sass</h2>
<p>安装gatsby-plugin-sass和sass。</p>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i sass gatsby-plugin-sass --save-dev
</pre></div>

</code></pre>
<p>在gatsby-config.js中包括插件。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="nx">plugins</span><span class="o">:</span><span class="p">[</span><span class="s1">&#39;gatsby-plugin-sass&#39;</span><span class="p">]</span>
</pre></div>

</code></pre>
<h1 id="-">添加本地图片和媒体资源</h1>
<p>两种方式来引入资源文件：1、直接在gatsby引用模板，页面和组件中引用；2、使用static folder，在某些场景下比较有用。</p>
<h2 id="-webpack-">在webpack中引入资源</h2>
<p>可以在JS模块中使用import来引入一个文件，import的结果为文件最终的路径。这个路径可以作为src，href的值。</p>
<p>对于svg、jpg、jpeg、png、gif、mp4、webm、wav、mp3、m4a、acc和oga文件，为了减少额外的服务器请求，import的页面少于10000字节会直接返回一个Data URI而不是path。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">girlImg</span> <span class="nx">from</span> <span class="s1">&#39;./../images/girl.jpeg&#39;</span><span class="p">;</span>
<span class="c1">// 这段代码会让webpack将image文件拷贝到public文件夹，同时提供正确的path。</span>
</pre></div>

</code></pre>
<p>也可以在CSS中import文件。</p>
<pre><code class="lang-css"><div class="highlight"><pre><span class="nt">background-image</span><span class="o">:</span> <span class="nt">url</span><span class="o">(</span><span class="s2">&quot;./../images/girl.jpeg&quot;</span><span class="o">)</span>
</pre></div>

</code></pre>
<p>webpack会找到所有的在CSS中的相对引用(以./开始的)，然后将最终的路径替换下。文件路径中webpack会自动添加内容hash值。</p>
<p>如果你使用scss，import是相对于与入口scss文件的。</p>
<h2 id="-graphql-gatsby-source-filesystem-">使用GraphQL和gatsby-source-filesystem来查询文件</h2>
<p>你可以使用GraphQL来import文件，这也会导致将这些文件拷贝到public文件夹。</p>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">import</span> <span class="nx">React</span> <span class="nx">from</span> <span class="s2">&quot;react&quot;</span>
<span class="kr">import</span> <span class="p">{</span> <span class="nx">useStaticQuery</span><span class="p">,</span> <span class="nx">graphql</span> <span class="p">}</span> <span class="nx">from</span> <span class="s2">&quot;gatsby&quot;</span>
<span class="kr">import</span> <span class="nx">Layout</span> <span class="nx">from</span> <span class="s2">&quot;../components/layout&quot;</span>
<span class="kr">const</span> <span class="nx">DownloadsPage</span> <span class="o">=</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kr">const</span> <span class="nx">data</span> <span class="o">=</span> <span class="nx">useStaticQuery</span><span class="p">(</span><span class="nx">graphql</span><span class="err">`</span>
    <span class="p">{</span>
      <span class="nx">allFile</span><span class="p">(</span><span class="nx">filter</span><span class="o">:</span> <span class="p">{</span> <span class="nx">extension</span><span class="o">:</span> <span class="p">{</span> <span class="nx">eq</span><span class="o">:</span> <span class="s2">&quot;pdf&quot;</span> <span class="p">}</span> <span class="p">})</span> <span class="p">{</span>
        <span class="nx">edges</span> <span class="p">{</span>
          <span class="nx">node</span> <span class="p">{</span>
            <span class="nx">publicURL</span>
            <span class="nx">name</span>
          <span class="p">}</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="err">`</span><span class="p">)</span>
  <span class="k">return</span> <span class="p">(</span>
    <span class="o">&lt;</span><span class="nx">Layout</span><span class="o">&gt;</span>
      <span class="o">&lt;</span><span class="nx">h1</span><span class="o">&gt;</span><span class="nx">All</span> <span class="nx">PDF</span> <span class="nx">Downloads</span><span class="o">&lt;</span><span class="err">/h1&gt;</span>
      <span class="o">&lt;</span><span class="nx">ul</span><span class="o">&gt;</span>
        <span class="p">{</span><span class="nx">data</span><span class="p">.</span><span class="nx">allFile</span><span class="p">.</span><span class="nx">edges</span><span class="p">.</span><span class="nx">map</span><span class="p">((</span><span class="nx">file</span><span class="p">,</span> <span class="nx">index</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
          <span class="k">return</span> <span class="p">(</span>
            <span class="o">&lt;</span><span class="nx">li</span> <span class="nx">key</span><span class="o">=</span><span class="p">{</span><span class="err">`</span><span class="nx">pdf</span><span class="o">-</span><span class="nx">$</span><span class="p">{</span><span class="nx">index</span><span class="p">}</span><span class="err">`</span><span class="p">}</span><span class="o">&gt;</span>
              <span class="o">&lt;</span><span class="nx">a</span> <span class="nx">href</span><span class="o">=</span><span class="p">{</span><span class="nx">file</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">publicURL</span><span class="p">}</span> <span class="nx">download</span><span class="o">&gt;</span>
                <span class="p">{</span><span class="nx">file</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">name</span><span class="p">}</span>
              <span class="o">&lt;</span><span class="err">/a&gt;</span>
            <span class="o">&lt;</span><span class="err">/li&gt;</span>
          <span class="p">)</span>
        <span class="p">})}</span>
      <span class="o">&lt;</span><span class="err">/ul&gt;</span>
    <span class="o">&lt;</span><span class="err">/Layout&gt;</span>
  <span class="p">)</span>
<span class="p">}</span>
<span class="kr">export</span> <span class="k">default</span> <span class="nx">DownloadsPage</span>
</pre></div>

</code></pre>
<h2 id="-gatsby-image-">使用Gatsby Image来避免图片过大</h2>
<p>安装gatsby-transformer-sharp和gatsby-plugin-sharp来转换和处理图片。</p>
<p>gatsby-image包含一个组件，它内部支持Gatsby的GraphQL查询。它将Gatsby的原生图片处理能力和图片加载技术结合起来。</p>
<p>gatsby-image并不总能替换&lt;img/&gt;，它需要固定宽高的图片，或充满父级元素的图片。</p>
<p>gatsby-image：</p>
<p>1、使用IntersectionObserver API来懒加载图片。</p>
<p>2、image的位置不会在图片加载过程中变动，主要是因为固定宽高。</p>
<p>3、可以使用占位符图片，一个灰色的背景或模糊不清的图片。</p>
<pre><code class="lang-bash"><div class="highlight"><pre>npm i gatsby-transformer-sharp gatsby-plugin-sharp gatsby-image
</pre></div>

</code></pre>
<h3 id="-">图片的问题</h3>
<p>大的，没有优化的图片会减慢你的网站，降低用户体验。</p>
<p>你需要做的工作很多：</p>
<p>1、调整大图到页面设计的大小。</p>
<p>2、为智能手机或平板生成小尺寸图片。</p>
<p>3、压缩jpeg和png，去掉额外的信息。</p>
<p>4、懒加载图片以提高首屏时间和减少流量损耗。</p>
<p>5、使用图片占位符，在图片加载时展示部分信息。</p>
<p>6、固定图片的位置，以免图片加载后布局大变动。</p>
<p>这些会耗费大量的人力。</p>
<h3 id="-">解决方案</h3>
<pre><code class="lang-js"><div class="highlight"><pre>    <span class="err">`</span><span class="nx">gatsby</span><span class="o">-</span><span class="nx">plugin</span><span class="o">-</span><span class="nx">image</span><span class="err">`</span><span class="p">,</span>
    <span class="p">{</span>
      <span class="nx">resolve</span><span class="o">:</span> <span class="err">`</span><span class="nx">gatsby</span><span class="o">-</span><span class="nx">source</span><span class="o">-</span><span class="nx">filesystem</span><span class="err">`</span><span class="p">,</span>
      <span class="nx">options</span><span class="o">:</span> <span class="p">{</span>
        <span class="nx">name</span><span class="o">:</span> <span class="err">`</span><span class="nx">images</span><span class="err">`</span><span class="p">,</span>
        <span class="nx">path</span><span class="o">:</span> <span class="err">`</span><span class="nx">$</span><span class="p">{</span><span class="nx">__dirname</span><span class="p">}</span><span class="o">/</span><span class="nx">src</span><span class="o">/</span><span class="nx">images</span><span class="err">`</span><span class="p">,</span>
      <span class="p">},</span>
    <span class="p">},</span>
    <span class="err">`</span><span class="nx">gatsby</span><span class="o">-</span><span class="nx">plugin</span><span class="o">-</span><span class="nx">sharp</span><span class="err">`</span><span class="p">,</span>
    <span class="err">`</span><span class="nx">gatsby</span><span class="o">-</span><span class="nx">transformer</span><span class="o">-</span><span class="nx">sharp</span><span class="err">`</span><span class="p">,</span>
</pre></div>

</code></pre>
<pre><code class="lang-js"><div class="highlight"><pre><span class="kr">export</span> <span class="kr">const</span> <span class="nx">query</span> <span class="o">=</span> <span class="nx">graphql</span><span class="err">`</span>
    <span class="nx">query</span> <span class="nx">MyQuery</span> <span class="p">{</span>
        <span class="nx">file</span><span class="p">(</span><span class="nx">relativePath</span><span class="o">:</span><span class="p">{</span><span class="nx">eq</span><span class="o">:</span><span class="s2">&quot;cat.jpeg&quot;</span><span class="p">}){</span>
            <span class="nx">childImageSharp</span> <span class="p">{</span>
               <span class="nx">gatsbyImageData</span><span class="p">(</span><span class="nx">width</span><span class="o">:</span><span class="mi">200</span><span class="p">,</span><span class="nx">placeholder</span><span class="o">:</span><span class="nx">BLURRED</span><span class="p">,</span><span class="nx">formats</span><span class="o">:</span><span class="p">[</span><span class="nx">AUTO</span><span class="p">,</span><span class="nx">WEBP</span><span class="p">,</span><span class="nx">AVIF</span><span class="p">])</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="err">`</span>
</pre></div>

</code></pre>
<h2 id="static-folder">Static Folder</h2>
<p>Gatsby推荐在JS文件中直接引用资源文件。因为下面的优点：</p>
<p>1、脚本和样式可以压缩并打包到一起，避免额外的网络请求。</p>
<p>2、缺少的文件会在编译时报错，而不是用户端报404错误。</p>
<p>3、打包时文件会带内容hash值，不用担心浏览器缓存旧版本。</p>
<p>还存在下面的缺点：</p>
<p>1、static文件夹里的内容都不会被额外的处理。eg：压缩，裁剪。</p>
<h3 id="-assets">在模块系统之外添加assets</h3>
<p>你可以在项目根目录创建一个static文件夹。里面的每一个文件夹会被拷贝到public文件夹。</p>
<h3 id="-static-">什么场景下使用static文件夹</h3>
<p>正常情况我们推荐使用stylesheets，images和字体资源。static文件夹在下列场景下有一些作用：</p>
<p>1、你需要一个特定名称的文件，eg：manifest.webmanifest。</p>
<p>2、你有数千张图片，需要动态引用它们的路径。</p>
<p>3、你想包含一个小段的JS，在打包的JS文件之外。</p>
<p>4、一些类库跟webpack不兼容，需要使用script tag。</p>
<p>5、一些很难用GraphQL处理的json文件。</p>
<h2 id="-">参考文档</h2>
<p><a href="https://v2.gatsbyjs.com/docs">https://v2.gatsbyjs.com/docs</a></p>
</body>
</html>
