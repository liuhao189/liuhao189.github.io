<!DOCTYPE html>
<html>
<head>
  <title>WebRender怎么保证渲染效率</title>
  <link rel="stylesheet" href="/note/note.css?ts=1651767932820">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="webrender-">WebRender怎么保证渲染效率</h1>
<h2 id="-">绘制和合成的历史</h2>
<p>注意：绘制和合成是浏览器差异比较大的部分。单平台浏览器(Edge和Safari)和跨平台浏览器(Firefox和Chrome)工作方式稍有不同。</p>
<p>即使是最早的浏览器，也有一些优化使得页面呈现得更快。eg：滚动内容时，浏览器将保留仍然可见的部分并移动它，然后，在空白点上绘制新的像素。</p>
<p>这种找出发生了什么变化，然后只更新发生变化的元素或像素的过程称为增量更新。随着时间的推移，浏览器开始应用更多的增量更新技术，比如矩形增量更新。</p>
<p>当页面上没有太多变化时，比如只有一个闪烁的光标，这确实减少了需要做的工作。但是，这对于大范围的页面变化，帮助并不大。</p>
<p><img src="/note/assets/imgs/cursor-changed.gif" alt="闪烁的光标"></p>
<h3 id="-">引入图层和合成器</h3>
<p>当页面大范围内容变化时，在某些情况下使用图层会很有帮助。</p>
<p>浏览器中的图层很像PS中的图层，你在不同的层上绘制页面的不同元素，然后把这些层合成在一起。</p>
<p>它们作为浏览器的一部分已经很长时间了，最初它们只是用来确保页面的正确呈现。例如：如果你有一个半透明的元素，它将在它自己的堆叠上下文中。这意味着它有它自己的图层。</p>
<p>某些情况下，某些图层的内容不会变化，浏览器会保留这些图层，浏览器只重新绘制已经改变的图层。某些情况下，图层没有变化，只需要重新合成即可。例如：动画在屏幕移动，滚动。</p>
<p><img src="/note/assets/imgs/scroll-layout.gif" alt="滚动的图层"></p>
<p>合成器从下面开始：</p>
<p>1、源位图：背景和可滚动内容本身。</p>
<p>2、目标位图：屏幕上展示的。</p>
<p>首先，合成器将背景拷贝到目标位图，然后，它会计算可滚动的哪个部分应该展示，然后将那部分拷贝到目标位图。</p>
<p>这减少了主线程必须完成的绘制工作，但这仍然意味着主线程需要花费时间来合成。</p>
<p>主线程有点像全栈开发人员，它负责DOM，布局和JS，还负责绘制和合成，这导致主线程非常忙。</p>
<p><img src="/note/assets/imgs/main-thread.png" alt="主线程工作"></p>
<p>但还有另一部分硬件闲置着，这个硬件就是GPU，专门为图形设计的。</p>
<h2 id="gpu-">GPU加速合成</h2>
<p>所以浏览器开发者将部分工作转移到GPU。</p>
<p>有两个任务会转移到GPU：</p>
<p>1、绘制图层。很难将绘制转移到GPU，大多数情况下，多平台浏览器都在CPU上绘制。</p>
<p>2、图层合成。合成GPU可以很快完成，而且容易转移到GPU。</p>
<p>有的浏览器甚至更进一步，在CPU上增加合成器线程，它成为了GPU合成工作的管理者。这将所有的合成工作从主线程移走。</p>
<p>它仍然在主线程上留下许多工作，每当需要重新绘制图层时，主线程需要绘制，然后将它转移给GPU。</p>
<p>一些浏览器将绘制转移到另一个线程(Firefox进行中)，但是把绘制转移到GPU会更快。</p>
<h2 id="gpu-">GPU加速绘制</h2>
<p>所以，浏览器开始将绘制转移到GPU。</p>
<p><img src="/note/assets/imgs/paint-to-gpu.png" alt="主线程工作"></p>
<p>在GPU上绘制的优点：1、它释放了CPU，把时间可以用来执行JS或布局。2、绘制像素方面，GPU比CPU快得多，所以它加快了绘制速度，也意味着从CPU复制更少的数据到GPU。</p>
<h2 id="-">什么时候浏览器会不稳定</h2>
<p>使用图层也有缺点：1、它们占用大量内存；2、某些情况下回很慢，浏览器无法区分有意义的图层合成。</p>
<p>这意味着如果页面有大量的元素需要移动，可能导致大量的图层，这些图层会耗费大量的内存，需要很长时间到合成器。</p>
<p><img src="/note/assets/imgs/too-many-layers.png" alt="大量图层"></p>
<p>另外一些时候，你可能只有一个图层(应该有多个图层时)，这个图层会一直绘制并转移到合成器(合成器不会改变任何东西)中。这种情况下，直接绘制页面会更快。</p>
<p>大多数场景下，图层不会太有用。例如：你在动画中改变background，整个图层必须不断绘制，图层只在特定CSS属性变化时才有用。</p>
<p>即使大多数帧都表现很好，只需要特定的几个帧表现不佳，用户就能感觉到卡顿。这种场景叫性能悬崖。你的APP一直表现得很好，直到某些最差的场景出现。</p>
<h2 id="-gpu">向游戏引擎一样使用GPU</h2>
<p>现代电子游戏重新绘制每一个像素，它们比浏览器更可靠地保持每秒60帧。它们不是创建无效的矩形和层来最小化需要绘制的内容，而是重新绘制整个屏幕。</p>
<p>这样渲染网页会不会更慢？如果使用CPU绘制，会更慢，但使用GPU绘制，不会更慢。CPU一般有2-8核，但是GPU至少有数百核心，一般会超过1000核。</p>
<p>因为核心需要同时处理相同的事情，GPU有一组非常严格的步骤，它们的API也非常有限。让我们看看它们是如何工作的？</p>
<p>首先，需要告诉GPU要画什么，这意味这赋予它形状并告诉它如何填充它们。你需要将你的绘画分解成简单的形状(通常是三角形)，这些形状是在3D空间中，然后取这写三角形的所有点并将它们的坐标放入一个数组中。</p>
<p><img src="/note/assets/imgs/triangle-array.png" alt="三角形数组"></p>
<p>然后可以调用GPU来绘制这些图形。GPU会做下面的事情：</p>
<p>1、找出形状的所有角落的位置，这叫做顶点阴影。</p>
<p>2、找出连接这些点的线，通过责怪，可以确定哪些像素被形状覆盖，这就是所谓的栅格化。</p>
<p>3、现在我们知道了形状所覆盖的像素，检查形状中的每个像素并找出它应该是什么颜色。这叫像素着色。</p>
<p>最后异步可以用不同的方法完成，为了告诉GPU如何做，你可以给GPU一个叫做像素着色器的程序。像素着色器是GPU中少数几个可以编程的部分之一。</p>
<p>一些像素着色器是简单的，例如，你的形状是单一颜色的。某些情况下，这个像素着色器会很复杂。例如：你有一个背景图片。你需要计算图片的哪块区域对应到哪些像素点。</p>
<p>你可以在图像上方设置对应于每个像素的网格，然后，一旦你知道哪个盒子对应的像素，对盒子里的颜色进行采样，找出颜色应该是什么。这称为纹理映射，因为它将图像(称为纹理)映射到像素。</p>
<p>GPU会在每个像素上调用你的像素着色程序。不同的核心将同时工作在不同的像素，但它们需要使用相同的像素着色程序。</p>
<p>对于几乎任何网页，页面的不同部分都需要使用不同的像素着色器。</p>
<p>因为着色器应用于绘制调用中的所有形状，你通常必须将绘制调用分成多个组。为了使所有核心尽可能忙碌，您需要创建少量批处理，其中包含许多形状。</p>
<p><img src="/note/assets/imgs/shape-batch.png" alt="三角形批量绘制"></p>
<h2 id="-">参考文档</h2>
<p><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/">https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/</a></p>
</body>
</html>
