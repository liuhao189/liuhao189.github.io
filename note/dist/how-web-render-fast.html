<!DOCTYPE html>
<html>
<head>
  <title>WebRender怎么保证渲染效率</title>
  <link rel="stylesheet" href="/note/note.css?ts=1652112646471">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="webrender-">WebRender怎么保证渲染效率</h1>
<h2 id="-">绘制和合成的历史</h2>
<p>注意：绘制和合成是浏览器差异比较大的部分。单平台浏览器(Edge和Safari)和跨平台浏览器(Firefox和Chrome)工作方式稍有不同。</p>
<p>即使是最早的浏览器，也有一些优化使得页面呈现得更快。eg：滚动内容时，浏览器将保留仍然可见的部分并移动它，然后，在空白点上绘制新的像素。</p>
<p>这种找出发生了什么变化，然后只更新发生变化的元素或像素的过程称为增量更新。随着时间的推移，浏览器开始应用更多的增量更新技术，比如矩形增量更新。</p>
<p>当页面上没有太多变化时，比如只有一个闪烁的光标，这确实减少了需要做的工作。但是，这对于大范围的页面变化，帮助并不大。</p>
<p><img src="/note/assets/imgs/cursor-changed.gif" alt="闪烁的光标"></p>
<h3 id="-">引入图层和合成器</h3>
<p>当页面大范围内容变化时，在某些情况下使用图层会很有帮助。</p>
<p>浏览器中的图层很像PS中的图层，你在不同的层上绘制页面的不同元素，然后把这些层合成在一起。</p>
<p>它们作为浏览器的一部分已经很长时间了，最初它们只是用来确保页面的正确呈现。例如：如果你有一个半透明的元素，它将在它自己的堆叠上下文中。这意味着它有它自己的图层。</p>
<p>某些情况下，某些图层的内容不会变化，浏览器会保留这些图层，浏览器只重新绘制已经改变的图层。某些情况下，图层没有变化，只需要重新合成即可。例如：动画在屏幕移动，滚动。</p>
<p><img src="/note/assets/imgs/scroll-layout.gif" alt="滚动的图层"></p>
<p>合成器从下面开始：</p>
<p>1、源位图：背景和可滚动内容本身。</p>
<p>2、目标位图：屏幕上展示的。</p>
<p>首先，合成器将背景拷贝到目标位图，然后，它会计算可滚动的哪个部分应该展示，然后将那部分拷贝到目标位图。</p>
<p>这减少了主线程必须完成的绘制工作，但这仍然意味着主线程需要花费时间来合成。</p>
<p>主线程有点像全栈开发人员，它负责DOM，布局和JS，还负责绘制和合成，这导致主线程非常忙。</p>
<p><img src="/note/assets/imgs/main-thread.png" alt="主线程工作"></p>
<p>但还有另一部分硬件闲置着，这个硬件就是GPU，专门为图形设计的。</p>
<h2 id="gpu-">GPU加速合成</h2>
<p>所以浏览器开发者将部分工作转移到GPU。</p>
<p>有两个任务会转移到GPU：</p>
<p>1、绘制图层。很难将绘制转移到GPU，大多数情况下，多平台浏览器都在CPU上绘制。</p>
<p>2、图层合成。合成GPU可以很快完成，而且容易转移到GPU。</p>
<p>有的浏览器甚至更进一步，在CPU上增加合成器线程，它成为了GPU合成工作的管理者。这将所有的合成工作从主线程移走。</p>
<p>它仍然在主线程上留下许多工作，每当需要重新绘制图层时，主线程需要绘制，然后将它转移给GPU。</p>
<p>一些浏览器将绘制转移到另一个线程(Firefox进行中)，但是把绘制转移到GPU会更快。</p>
<h2 id="gpu-">GPU加速绘制</h2>
<p>所以，浏览器开始将绘制转移到GPU。</p>
<p><img src="/note/assets/imgs/paint-to-gpu.png" alt="主线程工作"></p>
<p>在GPU上绘制的优点：1、它释放了CPU，把时间可以用来执行JS或布局。2、绘制像素方面，GPU比CPU快得多，所以它加快了绘制速度，也意味着从CPU复制更少的数据到GPU。</p>
<h2 id="-">什么时候浏览器会不稳定</h2>
<p>使用图层也有缺点：1、它们占用大量内存；2、某些情况下会很慢，浏览器无法区分有意义的图层合成。</p>
<p>这意味着如果页面有大量的元素需要移动，可能导致大量的图层，这些图层会耗费大量的内存，需要很长时间传递到合成器。</p>
<p><img src="/note/assets/imgs/too-many-layers.png" alt="大量图层"></p>
<p>另外一些时候，你可能只有一个图层(应该有多个图层时)，这个图层会一直绘制并转移到合成器(合成器不会改变任何东西)中。这种情况下，直接绘制页面会更快。</p>
<p>大多数场景下，图层不会太有用。例如：你在动画中改变background，整个图层必须不断绘制，图层只在特定CSS属性变化时才有用。</p>
<p>即使大多数帧都表现很好，只需要特定的几个帧表现不佳，用户就能感觉到卡顿。这种场景叫性能滑坡，你的APP一直表现得很好，直到某些最差的场景出现。</p>
<h2 id="-gpu">向游戏引擎一样使用GPU</h2>
<p>现代电子游戏重新绘制每一个像素，它们比浏览器更可靠地保持每秒60帧。它们不是创建无效的矩形和层来最小化需要绘制的内容，而总是重新绘制整个屏幕。</p>
<p>这样渲染网页会不会更慢？如果使用CPU绘制，会更慢，但使用GPU绘制，不会更慢。CPU一般有2-8核，但是GPU至少有数百核心，一般会超过1000核。</p>
<p>因为GPU核心需要同时处理相同的事情，GPU有一组非常严格的步骤，它们的API也非常有限。让我们看看它们是如何工作的？</p>
<p>首先，需要告诉GPU要画什么，这意味着赋予它形状并告诉它如何填充它们。你需要将你的绘画分解成简单的形状(通常是三角形)，这些形状是在3D空间中，然后取这写三角形的所有点并将它们的坐标放入一个数组中。</p>
<p><img src="/note/assets/imgs/triangle-array.png" alt="三角形数组"></p>
<p>然后可以调用GPU来绘制这些图形。GPU会做下面的事情：</p>
<p>1、找出形状的所有点的位置，这叫做顶点阴影。</p>
<p>2、找出连接这些点的线，可以确定哪些像素被形状覆盖，这就是所谓的栅格化。</p>
<p>3、现在我们知道了形状所覆盖的像素，检查形状中的每个像素并找出它应该是什么颜色。这叫像素着色。</p>
<p>最后一步可以用不同的方法完成，为了告诉GPU如何做，你可以给GPU一个叫做像素着色器的程序。像素着色器是GPU中少数几个可以编程的部分。</p>
<p>一些像素着色器是简单的，例如，你的形状是单一颜色的。某些情况下，这个像素着色器会很复杂。例如：你有一个背景图片。你需要计算图片的哪块区域对应到哪些像素点。</p>
<p>你可以在图像上方设置对应于每个像素的网格，然后，一旦你知道盒子对应的像素，对盒子里的颜色进行采样，找出颜色应该是什么。这称为纹理映射，因为它将图像(称为纹理)映射到像素。</p>
<p>GPU会在每个像素上调用你的像素着色程序。不同的核心将同时工作在不同的像素，但它们需要使用相同的像素着色程序。</p>
<p>对于几乎任何网页，页面的不同部分都需要使用不同的像素着色器。</p>
<p>因为着色器应用于绘制调用中的所有形状，你通常必须将绘制调用分成多个组。为了使所有核心尽可能忙碌，您需要创建少量批处理，其中包含许多形状。</p>
<p><img src="/note/assets/imgs/shape-batch.png" alt="三角形批量绘制"></p>
<h2 id="webrender-">WebRender是如何做的</h2>
<p>跟原来的浏览器渲染页面相比，两件事会改变。</p>
<p><img src="/note/assets/imgs/webrender-change-2.png" alt="WebRender两点不同"></p>
<p>1、绘制和合成不再区分，它们是同一步中的两部分。使用图形API使GPU同时处理绘制和合成。</p>
<p>2、布局信息之前被称为Frame-Tree或Render-Tree，现在传递为Display-List。</p>
<p>Display-List是高级绘制指令，它告诉我们需要绘制什么，而不会具体到图形API。</p>
<p>当有新的东西需要绘制时，主线程会将Dispaly-List给到RenderBackend（在CPU上运行的WebRender实例）。</p>
<p>RenderBackend工作是将这个高级绘图指令列表转换成GPU需要的绘图调用，这些调用被分批运行，以使得它们运行得更快。</p>
<p>RenderBackend想让它给GPU的绘制调用尽可能快地绘制，为此，它使用了一些不同的技术。</p>
<h3 id="-">从列表中删除不必要的形状（早期剔除）</h3>
<p>节省时间最好的方式是不做该事情。首先，RenderBackend会过滤掉不在屏幕内展示的条目。这个过程称为早期剔除。</p>
<h3 id="-">尽量减少中间纹理的数量(渲染任务树)</h3>
<p>CSS过滤器和堆叠上下文这样的效果使事情变得有点复杂。例如，一个不透明度为0.5的元素，且该元素有子元素。这样整个组都是透明的。</p>
<p>因为如此，你需要先把这个组渲染成一个纹理，每个盒子都是不透明的。然后，当你把它放入父体时，你可以改变整个纹理的不透明度。</p>
<p>堆叠上下文是可以嵌套的，父元素可能是另一个堆叠上下文的一部分。这意味着它必须被渲染到另一个中间纹理上。</p>
<p>为这些纹理创建空间是昂贵的。尽可能地，我们想把东西归入同一个中间纹理。</p>
<p>为了帮助GPU做到这一点，我们创建了一个渲染任务树。有了它，我们知道哪些纹理需要在其它纹理之前被创建。任何不依赖于其它纹理的纹理都可以在第一遍时创建，这意味着它们可以被分组在同一个中间纹理中。</p>
<p><img src="/note/assets/imgs/box-group.png" alt="box-group"></p>
<p>通过建立这个渲染任务树，可以计算出我们可以使用的最小数量的屏幕外渲染目标。</p>
<h3 id="-">将绘制调用分组(批处理)</h3>
<p>如何创建批次可以真正加快绘制，在同一批次中尽可能多地使用各种形状，有以下几个原因：</p>
<p>首先、每当CPU调用GPU时，CPU必须做很多工作。包括设置GPU，上传着色器程序，测试不同的硬件错误。CPU做这些工作时，GPU是空闲的。</p>
<p>第二、改变状态是有代价的，需要在批次之间改变着色器程序。在一个典型的GPU上，你需要等到所有的核心都完成当前着色器的工作。这称为排空管线，在管线耗尽之前，其它内核将处于闲置状态。</p>
<p><img src="/note/assets/imgs/gpu-pipeline.png" alt="gpu-pipeline"></p>
<p>在典型的桌面网页上，你在每一帧会有100次批绘制，每一次批绘制有几千个点，这样，可以更好的利用GPU的并行性。</p>
<p>目前，每种不同类型的元素都需要一个不同的着色器。例如：有一个border着色器，一个text着色器和一个图像着色器。</p>
<p>我们目前计划结合这些着色器，这将使我们有更大的批次。</p>
<h3 id="-alpha-z-">用不透明和alpha通道减少像素阴影(Z-剔除)</h3>
<p>现代网页中会有很多图形相互重叠的部分。例如：文本输入框在div(有背景色的)上，而div又在有背景色的body上。</p>
<p>当计算像素的颜色时，GPU需要计算出每个图形的像素颜色。WebRender会首先计算出顶层的像素颜色，对于下层的图形，会首先查看当前像素是否有设置颜色，如果有颜色，那就不会再次计算颜色。</p>
<p>这个算法在上层透明或半透明时会有问题，因为这种情况你需要混合两个像素的颜色，顺序也需要从底层到顶层。所以，半透明的形状会走其它特殊逻辑。</p>
<p>将工作拆分为不透明和alpha过程，然后跳过不需要像素计算的过程称为Z剔除。</p>
<p>这看起来像是一个简单的优化，但实际上带来了很大的速度提升。它大大减少了我们需要接触的像素数量。</p>
<h2 id="-gpu">警告：并不是所有东西都在GPU</h2>
<p>CPU仍然需要做一些绘制工作。例如：我们仍然在CPU上呈现文本块中使用的字符。在GPU上可以做到这一点，但很难获得与计算机其它应用程序中渲染的字体逐像素匹配。</p>
<p>我们正在试图通过Pathfinder项目将符号之类的东西移到GPU。</p>
<p>目前，这些东西会被CPU绘制为Bitmap，然后上传到GPU的纹理缓存中，这个缓存在不同的帧直接保持不变，因为它们通常不会改变。</p>
<h2 id="-">参考文档</h2>
<p><a href="https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/">https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/</a></p>
</body>
</html>
