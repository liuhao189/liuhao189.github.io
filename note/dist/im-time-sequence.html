<!DOCTYPE html>
<html>
<head>
  <title>如何保证IM实时消息的时序性和一致性</title>
  <link rel="stylesheet" href="/note/note.css?ts=1648481422397">
<meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0"><link rel="shortcut icon" href="/ico.png"></head>
<body><script>var _hmt = _hmt || [];
(function () {
    var hm = document.createElement("script");
    hm.src = "https://hm.baidu.com/hm.js?256376ad73e3e50091706bb3c032e74c";
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(hm, s);
})();
</script>
<h1 id="-im-">如何保证IM实时消息的时序性和一致性</h1>
<p>在一个IM系统中，很多业务场景都需要考虑消息投递的时序。比如说：</p>
<p>1、IM单聊信息投递，保证发送方发送顺序与接收方展现顺序一致。</p>
<p>2、IM中群聊消息投递，保证所有接收方展现顺序一致。</p>
<h2 id="-">为什么保证即时消息的时序一致性很难？</h2>
<h3 id="-">时钟不一致</h3>
<p>分布式环境下，有多个客户端，有Web集群，Service集群，db集群，他们都分布在不同的机器上，机器之间都使用本地时钟，而没有一个所谓的全局时钟，所以不能用本地时间来完全决定消息的时序。</p>
<h3 id="-">多客户端</h3>
<p>假设只有一台服务器，能否因那个本地时间表示时序呢？遗憾的是，由于多个客户端的存在，即使是一台服务器的本地时间，也无法表示绝对时序。</p>
<p>eg：app1发出msg1，app2发出msg2，都发往服务器web1；网络传输是不能保证msg1一定先于msg2到达的。</p>
<h3 id="-">多接收方</h3>
<p>假设只有一个发送方，能否用发送方的本地时间表示时序呢？</p>
<p>eg：app1先发出msg1，然后发出msg2，由于网络传输及多接收方的存在，无法保证msg1先被处理，故也无法保证msg1和msg2的处理时序。</p>
<h3 id="-">网络传输和多线程</h3>
<p>多发送方与多接收方都难以保证绝对时序。</p>
<p>eg：app1先发出msg1，后发出msg2，即使msg1先到达，由于多线程的存在，也不能保证msg1先被处理完。</p>
<h3 id="-">怎样保证绝对时序</h3>
<p>假设只有一个发送方，一个接收方，上下游连接只有一条连接池，通过阻塞的方式通讯，可以保证先发出的消息msg1先处理，但是，吞吐量会非常低。高并发高可用的架构不会允许这样的设计出现。</p>
<h2 id="-">生产环境下的优化方法总结</h2>
<h3 id="-">首先确定以客户端时序为准还是以服务器端时序为准</h3>
<p>根据业务场景，要判断出以客户端时序还是服务端时序为准。</p>
<p>eg：秒杀活动，肯定以服务器时间为准，不可能让客户端修改本地时间就能提前秒杀。</p>
<h3 id="-id">服务端能够生成单调递增的id</h3>
<p>利用单点写db的seq/auto_inc_id肯定能生成单调递增的id，只是性能及扩展会成为瓶颈。对于严格时序的业务场景，可以利用服务器的单调id来保证时序。</p>
<h3 id="-id">大部分业务能接受误差不大的趋势递增id</h3>
<p>消息发帖，帖子发布时间，甚至秒杀都没有那么精准时序的要求。eg：同1s内发布的聊天消息时序乱了，同1s内发布的帖子排序不对</p>
<p>大部分业务，长时间趋势递增的时序能够满足业务需求，非常短的时间的时序误差在一定程度上能够接受。</p>
<h3 id="-">单点序列化，可以保证多机相同时序</h3>
<p>数据为了保持高可用，需要做到进行数据冗余，同一份数据存储在多个地方，怎么保证这些数据是一致的呢？</p>
<p>eg：主从数据库，主库master来序列化所有SQL写操作，然后把相同的执行序列发送给从库slave执行。</p>
<p>eg：GFS(google file system)为了保证文件的可用性，一份文件要存储多份，也是由一个chunk-server先序列化写操作，再将序列化的操作发送到其它chunk-server，来保证冗余文件的数据一致性的。</p>
<h3 id="im-">IM中单聊，怎么保证发送顺序与接收顺序一致</h3>
<p>用户A发送了msg1，msg2，msg3给用户B，这三条消息能否保证显示时序（发送和显示的顺序一致）的一致性？</p>
<p>常见的优化方案为，在A发往B的消息中，加上发送方A本地的一个绝对时序，来表示接收方B的展现时序。</p>
<p>潜在问题是，如果接收方B先收到了msg3，msg3会展示，后收到msg1和msg2后，会展现在msg3的前面，这个也是没有办法的事情。</p>
<h3 id="im-">IM群聊消息，怎么保证各接收方收到顺序一致</h3>
<p>不能再利用发送方seq来保证时序，因为发送方不单点，时间也不一致。</p>
<p>可以利用服务器的单点做序列化，缺点是，这个生成的全局递增序列号的服务很容易成为系统瓶颈。</p>
<p>优化思路是：群消息不用保证全局有序，只需要保证一个群内的消息有序即可。id串行化就是一个很好的思路。</p>
<p>连接池层面做少量修改，实现按照gid选择下游服务，保证同一个群的消息落在一个服务器上，实现gid串行化，序列化。</p>
<h2 id="-">总结</h2>
<p>1、分布式环境下，消息的有序性是很难的，原因多种多样，时钟不一致，多发送方，多接收方，多线程，网络传输不确定性等。</p>
<p>2、要有序，先得有衡量有序的标尺，可以是客户端时序为准，也可以是服务端时序为准。</p>
<p>3、大部分业务能够接受大范围趋势有序，小范围误差，绝对有序的业务，可以借助服务器绝对时序的能力。</p>
<p>4、单点序列化，是一种常见的多时序统一的方法，典型场景有db主从一致，gfs多文件一致。</p>
<p>5、单对单聊天，只需要保证发出的时序与接收的时序一致，可以利用客户端seq。</p>
<p>6、群聊，只需要保证所有接收方消息时序一致，需要利用服务器seq，方法有两种，一种单点绝对时序，另一种是id串行化。</p>
<h2 id="-">参考文档</h2>
<p><a href="http://www.52im.net/thread-714-1-1.html">http://www.52im.net/thread-714-1-1.html</a></p>
</body>
</html>
