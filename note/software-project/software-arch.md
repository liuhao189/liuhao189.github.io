# 软件架构模式

本文观点和内容参考了《Software Architecture Patterns》的书。

## 为什么要学习基本的软件架构

1、了解了基本的软件架构知识，你可以更容易理解你所工作的软件项目。

2、知道基础的架构模式可以让你在写代码时做更好的决策。eg：如果你的应用基于事件驱动的微服务，那么做为软件工程师你必须将越来越复杂的代码拆分为独立的服务。

## 五种模式

1、分层结构。

2、事件驱动结构。

3、微内核架构或插件结构。

4、微服务体系结构。

5、云架构模式。

## 分层结构

对于单体应用来说，是最常见的软件结构。该模式背后的基本思想是将应用程序逻辑分为几个层，每个层封装特定类型的功能。

eg：持久化层负责app和db的通讯。

![分层结构图](/note/assets/imgs/layer-software-arch.png)

## 事件驱动结构

该模式背后的基本思想是将应用程序分为单一职责的事件处理组件。该组件可以接收并处理事件。

该模式是一种流行的分布式异步体系结构模式，以高可扩展性和适应性而闻名。

![事件驱动结构图](/note/assets/imgs/event-software-arch.png)

## 微内核结构或插件结构

微内核结构，也被称为插件结构。在设计时分为两个组件：核心系统和插件模式。一个比较好的例子是浏览器，你可以安装很多浏览器插件。

![插件结构图](/note/assets/imgs/plugin-software-arch.png)

## 微服务结构

微服务体系结构由单独部署的服务组成，其中每个服务都有单一的职责。这些服务是彼此独立的，如果一个服务失败，其它服务不会停止运行。

![微服务结构图](/note/assets/imgs/microservices-software-arch.png)

## 基于空间的结构

基于空间的模式背后的主要思想是分布式共享内存，以缓解数据库级别经常出现的问题。我们的假设是，通过使用内存中的数据处理大多数操作，我们可以避免数据库中的额外操作，从而避免将来可能出现的任何问题。

基本方式是将应用程序划分为多个处理单元(可根据需要自动放大和缩小)，在这些单元之间复制和处理数据，而无需将数据持久化到中央数据库。

![基于空间的结构图](/note/assets/imgs/space-software-arch.png)

# 软件架构模式

开发人员在没有正式的体系结构的情况下开始编写应用程序是很常见的。

如果没有清晰且定义良好的体系结构，大多数开发人员和架构师将求助于事实上的标准传统分层体系结构模式。

通过将源代码模块分离到包中来创建隐式层，不幸的是，这种做法会产生一系列无组织的源代码模块，它们之间缺乏明确的角色、责任和关系。这被称为大泥球反模式架构。

缺乏正式体系结构的应用程序通常是紧密耦合的、脆弱的，难以变更的，并且没有明确的愿景和方向。

不充分了解系统中每个组件和模块的内部工作原理，就很难确定应用程序的体系结构特征。关于部署和维护的基本问题很难回答。eg：架构是否可以扩展？应用程序的性能特征是什么？应用程序响应变更的难易程度？
应用程序的部署特征是什么？体系结构的响应能力如何？

架构模式有助于定义应用程序的基本特征和行为。eg：一些架构模式适用于高度可伸缩，其它架构适用于高度敏捷的应用程序。了解每种架构模式的优点和缺点对于选型至关重要。

作为架构师，你必须始终证明您的体系结构决策是正确的，尤其是在选择特定的体系结构模式或方法时。

## 分层架构

最常见的架构模式是分层架构模式。分层架构和大多数公司的组织结构紧密匹配，使其成为大多数业务应用程序开发的自然选择。

分层体系架构中的组件被组织成水平层，每个层执行特定的功能。eg：表示逻辑和业务逻辑。

大多数分层架构的软件分为四层，表现层，业务层，持久化层，DB层。

每一层有特定的功能。eg：表现层会处理所有用户发起的请求。业务层执行请求关联的业务逻辑。

分层架构模式的一个强大特性是组件之间的关注点分离。

分层体系中的每个层都标记为已关闭，这是分层体系架构中非常重要的概念。封闭层意味着当请求从一层移动到另一层时，必须穿过它正下方的层。

为什么不允许表示层直接访问持久层或数据层呢？这个问题的答案在于隔离层的关键概念。

隔离层概念意味着在体系结构中的一个层所做的更改通常不会影响其它层的组件，该更改被隔离到该层中的组件，只有可能影响到关联层。如果不这样，就会产生一个组件之间有大量相互依赖关系的紧密耦合的应用程序，这种类型的体系结构很难改变。

隔离层的概念还意味着每个层独立于其它层，因此对体系结构中的其它层的内部工作知之甚少或一无所知。eg：考虑将JSP转换为JSF。

虽然封闭层有助于隔离，但是某些层是开放的是有意义的。eg：共享服务层添加到包含业务层中的公共服务组件（数据和字符串应用程序类，审核和日志类）。创建服务层通常是一个好主意，因为它将对共享服务的访问限制在业务层上。

![开放分层结构图](/note/assets/imgs/open-layer-software-arch.png)

利用开放层和封闭层的概念有助于定义体系架构层和请求流之间的关系。

### 分层结构特点

分层结构是一种可靠的通用模式，当您不确定哪种体系结构最适合您的应用时，可以先采用此模式。

但有两个方面需要考虑。

首先要注意的是所谓的体系结构的反模式。eg：请求通过架构的多个层，但多个层只作简单的传递处理，在每一层执行很少或没有逻辑。

每一个分层结构都至少有一些场景属于反模式，关键是分析百分比。如果发现大部分请求都是简单得传递处理，可能需要考虑将一些体系架构层打开。

第二个考虑因素是分层架构倾向于单体应用程序。

### 模式分析

1、整体敏捷性：差，虽然有隔离层，但由于大多数实现的整体性以及通常的组件紧耦合，该体系结构中进行更改仍非常繁琐和耗时。

2、易于部署：差，部署可能会成为一个问题。组件的一个小更改可能需要重新部署整个应用程序。

3、可测试性：高，其它层可以被很容易模拟，使得此模式相对容易测试。

4、性能：低，由于必须通过体系结构的多个层来处理。

5、可伸缩性：低，由于该模式的紧密耦合和单体应用实现的趋势。可以通过将层拆分为单独的物理部署或将整个应用部署到多个节点，但总体而言，粒度太宽。

6、易于开发：高，该模式是众所周知的，并且实现起来也不复杂。

## 事件驱动架构

事件驱动的体系结构模式是一种流行的分布式异步体系结构模式，用于生成高度可伸缩的应用程序。

事件驱动的架构由高度解耦、单一用途的事件处理器组成，这些组件异步接收和处理事件。

事件驱动的体系结构由两个主要的拓扑组成，即中介和代理。需要通过中心中介者来协调事件中的多个步骤时，通常使用中介模式。不希望使用中心中介者的情况下，使用代理模式。

### 中介拓扑

中介拓扑对于具有多个步骤并需要某种级别的编排来处理事件的事件非常有用。eg：股票交易处理，首先验证该交易，检查股票交易是否符合各种合规规范，将交易分配给经纪人，计算佣金，最后与经纪人进行交易。这些步骤都需要某种程度的编排，以确定步骤的顺序，以及哪些步骤可以串行或并行完成。

中介拓扑中有四种主要组件：事件队列，事件中介，事件通道和事件处理器。

事件流从客户端向事件队列发送事件开始，事件队列将事件传输到事件中介。事件中介接收初始事件，并通过向事件通道发送额外的异步事件类协调该事件。以执行流程中的每个步骤。

事件处理器监听事件通道，从事件中介接收事件，并执行特定的业务逻辑来处理事件。


![开放分层结构图](/note/assets/imgs/mediator-event-software-arch.png)


在事件驱动的体系结构中，通常有十几个到几百个事件队列。事件队列可以是消息队列，web服务端点或它们的任何组合。

两种类型的事件：初始事件和处理事件，初始事件是中介接收的原始事件，而处理事件是中介生成并由处理组件接收的事件。

事件中介组件负责编排初始事件中包含的步骤。事件中介并不实际执行处理初始事件所需的业务逻辑，相反，它知道处理初始事件所需的步骤。

事件中介使用事件通道将与初始事件中的每个步骤相关的特定事件异步传递给事件处理器。通道可以是消息队列或消息主题。消息主题广泛使用，因为消息主题可以被多个事件处理器订阅。

事件处理器组件包含处理事件所需的应用程序业务逻辑，事件处理器是自包含的，独立的，高度解耦的体系结构组件，在应用程序或系统中执行特定的任务。

事件处理器的组件粒度可以从细粒度到粗粒度不等，但是，一般每个事件处理器组件应该执行单个业务任务，而不依赖于其它事件处理器来完成特定的任务。

事件中介可以通过多种方式实现，作为一名架构师，你应该理解这些实现选项中的每一个，以确保为事件中介选择的解决方案符合您的需求。

最简单和最常见的实现是通过Spring intergration、Apache Cemel或Mule ESB等开源集成中心实现的。

这些开源集成集线器中的事件流通常通过Java代码或DSL实现。对于更复杂的中介和编排，您可以使用BPEL(Business-Process-Execution-Language)和BPEL引擎结合使用。

BPEL是一种标准的类XML的语言，它描述了处理初始事件所需的数据和步骤。对于需要更复杂的编排，你可以使用阢流程管理器（BPM-Business-Process-Manager）。




## 参考文档

https://orkhanscience.medium.com/software-architecture-patterns-5-mins-read-e9e3c8eb47d2

https://www.oreilly.com/content/software-architecture-patterns/